#!/usr/bin/env perl
#-----------------------------------------------------------------------------------------------
#
# build-namelist
#
# This script builds the namelists for the POP configuration
#
# build-namelist uses a config_cache.xml file that current contains the ocean grid information.
# build-namelist reads this file to obtain information it needs to provide
# default values that are consistent with the POP library.  For example, the grid resolution
# is obtained from the cache file and used to determine appropriate defaults for namelist input
# that is resolution dependent.
#
# The simplest use of build-namelist is to execute it from the build directory where configure
# was run.  By default it will use the config_cache.xml file that was written by configure to
# determine the build time properties of the executable, and will write the files that contain
# the output namelists in that same directory.
#
#
# Date        Contributor      Modification
# -------------------------------------------------------------------------------------------
# 2012-01-30  Vertenstein      Original version
#--------------------------------------------------------------------------------------------
use strict;
use Cwd qw( getcwd abs_path chdir );
use English;
use Getopt::Long;
use IO::File;

no if ($PERL_VERSION ge v5.18.0), 'warnings' => 'experimental::smartmatch';

#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;
SYNOPSIS
     build-namelist [options]
OPTIONS
     -infile "filepath"    Specify a file containing namelists to read values from.
     -namelist "namelist"  Specify namelist settings directly on the commandline by supplying
                           a string containing FORTRAN namelist syntax, e.g.,
                              -namelist "&pop_nml dt=1800 /"
     -help [or -h]         Print usage to STDOUT.
     -test                 Enable checking that input datasets exist on local filesystem.
     -verbose              Turn on verbose echoing of informational messages.
     -caseroot             CASEROOT directory variable
     -cimeroot             CIMEROOT directory variable
     -ocn_grid             OCN_GRID variable
     -cfg_grid             Directory containing POP configuration scripts.
                           If not defined, location is set as \$ProgDir or \$cwd
                           (Needed to run build-namelist from SourceMods dir)
     -inst_string          inst_string variable
     -ntasks               number of ocean tasks

NOTE: The precedence for setting the values of namelist variables is (highest to lowest):
      1. namelist values set by specific command-line options, i.e. (none right now)
      2. values set on the command-line using the -namelist option,
      3. values read from the file specified by -infile,
      4. values from the namelist defaults file - or values specifically set in build-namelist
EOF
}

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the POP configuration scripts.  If the command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) {
    $cfgdir = abs_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

#-----------------------------------------------------------------------------------------------

# Process command-line options.

my %opts = ( help        => 0,
             test        => 0,
             verbose     => 0,
             preview     => 0,
             caseroot    => undef,
             cimeroot    => undef,
             inst_string => undef,
             ocn_grid    => undef,
             cfg_dir     => $cfgdir,
	     ntasks      => undef,
           );

GetOptions(
    "h|help"        => \$opts{'help'},
    "infile=s"      => \$opts{'infile'},
    "namelist=s"    => \$opts{'namelist'},
    "v|verbose"     => \$opts{'verbose'},
    "caseroot=s"    => \$opts{'caseroot'},
    "cimeroot=s"    => \$opts{'cimeroot'},
    "inst_string=s" => \$opts{'inst_string'},
    "ocn_grid=s"    => \$opts{'ocn_grid'},
    "cfg_dir=s"     => \$opts{'cfg_dir'},
    "preview"       => \$opts{'preview'},
    "ntasks=s"      => \$opts{'ntasks'},
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Check for unparsed arguments
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

# Define print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (currently not used)
# 2 - verbose
my $print = 0;
my $preview = 0;
if ($opts{'verbose'}) { $print = 2; }
if ($opts{'preview'}) { $preview = 1; }
my $eol = "\n";

if ($print>=2) { print "Setting POP configuration script directory to $cfgdir$eol"; }

my $CASEROOT    = $opts{'caseroot'};
my $CIMEROOT    = $opts{'cimeroot'};
my $OCN_GRID    = $opts{'ocn_grid'};
my $inst_string = $opts{'inst_string'};
my $ntasks      = $opts{'ntasks'};
$cfgdir         = $opts{'cfg_dir'};

# Validate some of the commandline option values.
validate_options("commandline", \%opts);

#-----------------------------------------------------------------------------------------------
# Make sure we can find required perl modules, definition, and defaults files.
# Look for them under the directory that contains the configure script.

# The root directory for the perl5 required utilities
my $perl5lib = "$CIMEROOT/utils/perl5lib";

# The Build::Config module provides utilities to access the configuration information
# in the config_cache.xml file (see below)
(-f "$perl5lib/Build/Config.pm")  or  die <<"EOF";
** $ProgName - Cannot find perl module \"Build/Config.pm\" in directory \"$perl5lib\" **
EOF

# The Build::NamelistDefinition module provides utilities to validate that the output
# namelists are consistent with the namelist definition file
(-f "$perl5lib/Build/NamelistDefinition.pm")  or  die <<"EOF";
** $ProgName - Cannot find perl module \"Build/NamelistDefinition.pm\" in directory \"$perl5lib\" **
EOF

# The Build::NamelistDefaults module provides a utility to obtain default values of namelist
# variables based on finding a best fit with the attributes specified in the defaults file.
(-f "$perl5lib/Build/NamelistDefaults.pm")  or  die <<"EOF";
** $ProgName - Cannot find perl module \"Build/NamelistDefaults.pm\" in directory \"$perl5lib\" **
EOF

# The Build::Namelist module provides utilities to parse input namelists, to query and modify
# namelists, and to write output namelists.
(-f "$perl5lib/Build/Namelist.pm")  or  die <<"EOF";
** $ProgName - Cannot find perl module \"Build/Namelist.pm\" in directory \"$perl5lib\" **
EOF

# The namelist definition file contains entries for all namelist variables that
# can be output by build-namelist.  The version of the file that is associate with a
# fixed POP tag is $cfgdir/namelist_files/namelist_definition.xml.  To aid developers
# who make use of the SourceMods/src.pop directory - we allow the definition file
# to come from that directory
my $nl_definition_file;
if (-f "${CASEROOT}/SourceMods/src.pop/namelist_definition_pop.xml") {
    $nl_definition_file = "${CASEROOT}/SourceMods/src.pop/namelist_definition_pop.xml";
}
if (! defined $nl_definition_file) {
    # default location of namelist definition file
    $nl_definition_file = "$cfgdir/namelist_files/namelist_definition_pop.xml";
    (-f "$nl_definition_file")  or  die <<"EOF";
    ** $ProgName - ERROR: Cannot find namelist definition file \"$nl_definition_file\" **
EOF
}
if ($print>=2) { print "Using namelist definition file $nl_definition_file$eol"; }

# The namelist defaults file contains default values for all required namelist variables.
my $nl_defaults_file;
if (-f "${CASEROOT}/SourceMods/src.pop/namelist_defaults_pop.xml") {
    $nl_defaults_file = "${CASEROOT}/SourceMods/src.pop/namelist_defaults_pop.xml";
}
if (! defined $nl_defaults_file) {
    $nl_defaults_file = "$cfgdir/namelist_files/namelist_defaults_pop.xml";
    (-f "$nl_defaults_file")  or  die <<"EOF";
    ** $ProgName - Cannot find namelist defaults file \"$nl_defaults_file\" **
EOF
}
if ($print>=2) { print "Using namelist defaults file $nl_defaults_file$eol"; }

#-----------------------------------------------------------------------------------------------
# Add $perl5lib_dir to the list of paths that Perl searches for modules
unshift @INC, "$perl5lib";
require Build::Config;
require Build::NamelistDefinition;
require Build::NamelistDefaults;
require Build::Namelist;
require Config::SetupTools;

#-----------------------------------------------------------------------------------------------

# Create a configuration object from the POP config_cache.xml file in $CASEROOT/Buildconf/popconf
my $cfg = Build::Config->new('config_cache.xml');

# Create a namelist definition object.  This object provides a method for verifying that the
# output namelist variables are in the definition file, and are output in the correct
# namelist groups.
my $definition = Build::NamelistDefinition->new($nl_definition_file);

# Create a namelist defaults object.  This object provides default values for variables
# contained in the input defaults file.  The configuration object provides attribute
# values that are relevent for the POP library for which the namelist is being produced.
my $defaults = Build::NamelistDefaults->new($nl_defaults_file, $cfg);

# Create an empty namelist object.  Add values to it in order of precedence.
my $nl = Build::Namelist->new();

#-----------------------------------------------------------------------------------------------
# Process the user input in order of precedence.  At each point we'll only add new
# values to the namelist and not overwrite previously specified specified values which
# have higher precedence.

# Process the commandline args that provide specific namelist values.

# Process the -namelist arg.
if (defined $opts{'namelist'}) {
    # Parse commandline namelist
    my $nl_arg = Build::Namelist->new($opts{'namelist'});

    # Validate input namelist -- trap exceptions
    my $nl_arg_valid;
    eval { $nl_arg_valid = $definition->validate($nl_arg); };
    if ($@) {
      die "$ProgName - ERROR: Invalid namelist variable in commandline arg '-namelist'.\n $@";
    }

    # Merge input values into namelist.  Previously specified values have higher precedence
    # and are not overwritten.
    $nl->merge_nl($nl_arg_valid);
}

# Process the -infile arg.
if (defined $opts{'infile'}) {
    # Parse namelist input from a file
    my $nl_infile = Build::Namelist->new($opts{'infile'});
    my $nl_infile_valid = Build::Namelist->new();

    # Validate namelist variables (going to do this one variable at a time)
    for my $group ($nl_infile->get_group_names()) {
      for my $var ($nl_infile->get_variable_names($group)) {
        my $var_local; # Name of variable to write to infile
        my $nl_check_var = Build::Namelist->new();
        my $nl_check_valid;
        my $val = $nl_infile->get_variable_value($group, $var);
        my @broken = split(/&/,$var);
        my $check_grp = 0; # If 1, make sure group found in definitions file
                           # matches that specified in user_nl_pop

        # if variable has ampersand, truncate it unless it is type derived
        if ($broken[1]) {
          my $nl_check_amp = Build::Namelist->new();
          $nl_check_amp->set_variable_value($group, $var, $val);
          eval { $definition->validate($nl_check_amp) };
          if (not $@) {
            # & is required in variable name
            $var_local = $var;
          } else {
            # & should not be in variable name
            $var_local = $broken[0];
            $check_grp = 1;
          }
        } else {
          $var_local = $var;
        }

        # Make sure variable is defined in namelist_definition_pop.xml
        $nl_check_var->set_variable_value($group, $var_local,$val);
        eval { $nl_check_valid = $definition->validate($nl_check_var); };
        (not $@) or die <<"EOF";
** ERROR: either $var_local is not a valid POP namelist variable or $var_local = $val is not a valid value; please fix user_nl_pop. Note that $var_local may appear in multiple namelists, in which case you need to specify the correct namelist in user_nl_pop using the format $var_local\&namelist_nml = $val, where \&namelist_nml is the pop_in namelist containing $var_local.**
EOF

        # If group was specified in user_nl_pop, make sure it matches
        # the group in the definitions file.
        my @group_valid = $nl_check_valid->get_group_names();
        ((not $check_grp) or ($broken[1] eq $group_valid[0])) or die <<"EOF";
** ERROR: $broken[0] is in $group_valid[0], not $broken[1]! Please fix this in user_nl_pop. **
EOF

        # Add variable to validated namelist
        $nl_infile_valid->set_variable_value($group_valid[0], $var_local, $val);
      }
    }

    # If preview is desired and something has been changed in $nl_infile_valid,
    # output everything in $nl_infile_valid
    if (($preview == 1) && ($nl_infile_valid->get_group_names)) {
      print " - The following values have been set in user_nl_pop:\n";
      print_nl_to_screen($nl_infile_valid);
    }
    # Merge input values into namelist.  Previously specified values have higher
    # precedence and are not overwritten.
    $nl->merge_nl($nl_infile_valid);
}

#-----------------------------------------------------------------------------------------------
# Determine xml variables

my %xmlvars = ();
SetupTools::getxmlvars($CASEROOT, \%xmlvars);
$xmlvars{DIN_LOC_ROOT} = SetupTools::expand_xml_var($xmlvars{DIN_LOC_ROOT}, \%xmlvars);
foreach my $attr (keys %xmlvars) {
  $xmlvars{$attr} = SetupTools::expand_xml_var($xmlvars{$attr}, \%xmlvars);
}

my $RUNDIR                 = "$xmlvars{'RUNDIR'}";
my $SRCROOT                = "$xmlvars{'SRCROOT'}";
my $DIN_LOC_ROOT           = "$xmlvars{'DIN_LOC_ROOT'}";
my $CASE                   = "$xmlvars{'CASE'}";
my $CALENDAR               = "$xmlvars{'CALENDAR'}";
my $CCSM_CO2_PPMV          = "$xmlvars{'CCSM_CO2_PPMV'}";
my $CCSM_BGC               = "$xmlvars{'CCSM_BGC'}";
my $NCPL_BASE_PERIOD       = "$xmlvars{'NCPL_BASE_PERIOD'}";
my $OCN_NCPL               = "$xmlvars{'OCN_NCPL'}";
my $OCN_COUPLING           = "$xmlvars{'OCN_COUPLING'}";
my $OCN_ICE_FORCING        = "$xmlvars{'OCN_ICE_FORCING'}";
my $OCN_CHL_TYPE           = "$xmlvars{'OCN_CHL_TYPE'}";
my $OCN_CO2_TYPE           = "$xmlvars{'OCN_CO2_TYPE'}";
my $OCN_TRANSIENT          = "$xmlvars{'OCN_TRANSIENT'}";
my @OCN_TRACER_MODULES     = split(" ", "$xmlvars{'OCN_TRACER_MODULES'}");
my $OCN_TRACER_MODULES_OPT = "$xmlvars{'OCN_TRACER_MODULES_OPT'}";
my $OCN_TAVG_TRACER_BUDGET = "$xmlvars{'OCN_TAVG_TRACER_BUDGET'}";
my $OCN_TAVG_HIFREQ        = "$xmlvars{'OCN_TAVG_HIFREQ'}";
my $OCN_ONEDIM             = "$xmlvars{'OCN_ONEDIM'}";
my $POP_DECOMPTYPE         = "$xmlvars{'POP_DECOMPTYPE'}";
my $INFO_DBUG              = "$xmlvars{'INFO_DBUG'}";
my $RUN_TYPE               = "$xmlvars{'RUN_TYPE'}";
my $RUN_STARTDATE          = "$xmlvars{'RUN_STARTDATE'}";
my $RUN_REFDATE            = "$xmlvars{'RUN_REFDATE'}";
my $CONTINUE_RUN           = "$xmlvars{'CONTINUE_RUN'}";
my $DEBUG                  = "$xmlvars{'DEBUG'}";
my $ICE_NCAT               = $xmlvars{'ICE_NCAT'};
my $POP_PASSIVE_TRACER_RESTART_OVERRIDE = "$xmlvars{'POP_PASSIVE_TRACER_RESTART_OVERRIDE'}";
my $ROF_GRID               = "$xmlvars{'ROF_GRID'}";
my $OCN_NDEP_DRIVER    = "$xmlvars{'OCN_NDEP_DRIVER'}";

expand_xml_variables_in_namelist($nl, \%xmlvars);

my $output_r = "./${CASE}.pop.r";
my $output_h = "./${CASE}.pop.h";
my $output_d = "./${CASE}.pop.d";
if ($inst_string) {
    $output_r = "./${CASE}.pop${inst_string}.r";
    $output_h = "./${CASE}.pop${inst_string}.h";
    $output_d = "./${CASE}.pop${inst_string}.d";
}

# Environment variables set in pop.buildnml.csh that are not xml variables
my $RESTART_INPUT_TS_FMT = "$ENV{'RESTART_INPUT_TS_FMT'}";
my $LID = $ENV{'LID'};

if ($CONTINUE_RUN eq 'TRUE') {$RUN_TYPE = "continue";}

my $iyear0  = `echo $RUN_STARTDATE | cut -c1-4  | sed -e 's/^0*//'`;
$iyear0 =~ s/\n/ /g; # remove imbedded newline
$iyear0 = $iyear0+0;

my $imonth0 = `echo $RUN_STARTDATE | cut -c6-7  | sed -e 's/^0*//'`;
$imonth0 =~ s/\n/ /g; # remove imbedded newline
$imonth0 = $imonth0+0;

my $iday0   = `echo $RUN_STARTDATE | cut -c9-10 | sed -e 's/^0*//'`;
$iday0 =~ s/\n/ /g; # remove imbedded newline
$iday0 = $iday0+0;

my $ihour0  = 0;
my $iminute0 = 0;
my $isecond0 = 0;

# coupled_freq and coupled_freq_opts depend on
# environment variables NCPL_BASE_PERIOD and OCN_NCPL
# Note that env_run.xml couples OCN_NCPL times per NCPL_BASE_PERIOD
# while POP couples every coupled_freq [in units of coupled_freq_opts]
# Example: OCN_NCPL = 4, NCPL_BASE_PERIOD = day => couple 4 times a day
#          coupled_freq = 4, coupled_freq_opts = nday => couple every 4 days
#
# Also need to know coupled_freq and coupled_freq_opts to set start time
# in time_manager_nml
my $coupled_freq;
my $coupled_freq_opt = 'nsecond';
my $sec_per_base_period;
if ($NCPL_BASE_PERIOD eq 'hour') {
  $sec_per_base_period = 3600;
} elsif ($NCPL_BASE_PERIOD eq 'day') {
  $sec_per_base_period = 3600 * 24;
} elsif ($NCPL_BASE_PERIOD eq 'year') {
  if ($CALENDAR eq 'NO_LEAP') {
    $sec_per_base_period = 3600 * 24 * 365;
  } else {
    die "$ProgName: ERROR invalid CALENDAR for NCPL_BASE_PERIOD $NCPL_BASE_PERIOD";
  }
} elsif ($NCPL_BASE_PERIOD eq 'decade') {
  if ($CALENDAR eq 'NO_LEAP') {
    $sec_per_base_period = 3600 * 24 * 365 * 10;
  } else {
    die "$ProgName: ERROR invalid CALENDAR for NCPL_BASE_PERIOD $NCPL_BASE_PERIOD";
  }
} else {
  die "$ProgName: ERROR invalid NCPL_BASE_PERIOD $NCPL_BASE_PERIOD";
}

if ($sec_per_base_period < 0) {
  die "$ProgName: ERROR integer overflow $sec_per_base_period should be positive";
}

if ($sec_per_base_period % $OCN_NCPL == 0) {
  $coupled_freq = $sec_per_base_period/$OCN_NCPL;
} else {
  die "$ProgName: Coupling $OCN_NCPL times per $NCPL_BASE_PERIOD is not an integer number of seconds per coupling period";
}
if ($coupled_freq % 3600 == 0) {
  $coupled_freq = $coupled_freq / 3600;
  $coupled_freq_opt = 'nhour';
#  print $sec_per_base_period/$OCN_NCPL," seconds = $coupled_freq hour(s)\n";
  if ($coupled_freq % 24 == 0) {
    $coupled_freq = $coupled_freq / 24;
    $coupled_freq_opt = 'nday';
#    print $sec_per_base_period/$OCN_NCPL," seconds = $coupled_freq day(s)\n";
    if ($coupled_freq % 365 == 0) {
      $coupled_freq = $coupled_freq / 365;
      $coupled_freq_opt = 'nyear';
#      print $sec_per_base_period/$OCN_NCPL," seconds = $coupled_freq year(s)\n";
    }
  }
}

# tmp starts with units of seconds, will cycle through minutes, hours, and days
# and increase isecond0, iminute0, ihour0, and iday0 as necessary. Note that at
# this point I don't know how to toggle months, so errors might occur with
# abnormally large coupling frequency.
my $tmp = $sec_per_base_period/$OCN_NCPL;
my $remainder;
# increase seconds
$remainder = $tmp%60;
$isecond0 += $remainder;
# increase minutes
$tmp = ($tmp - $remainder)/60;
$remainder = $tmp%60;
$iminute0 += $remainder;
# increase hours
$tmp = ($tmp - $remainder)/60;
$remainder = $tmp%24;
$ihour0 += $remainder;
# increase days
$tmp = ($tmp - $remainder)/24;
if ($tmp > 0) {
  $iday0 += $tmp;
  # check to see if need to roll into new month / year
  while (not valid_date(\$iday0, \$imonth0, \$iyear0, $CALENDAR)) {}
}

if ($print>=2) {
    print "POP build-namelist: ocn_grid is $OCN_GRID \n";
    print "POP build-namelist: ocn_tracer_modules are @OCN_TRACER_MODULES \n";
    print "Inputdata root directory: $DIN_LOC_ROOT$eol";
}

#-----------------------------------------------------------------------------------------------
# Determine namelist
#-----------------------------------------------------------------------------------------------

##################################
# namelist group: domain_nml     #
##################################

add_default($nl, 'nprocs_clinic', 'val'=>"$ntasks");
add_default($nl, 'nprocs_tropic', 'val'=>"$ntasks");
add_default($nl, 'clinic_distribution_type', 'val'=>"$POP_DECOMPTYPE");
add_default($nl, 'tropic_distribution_type', 'val'=>"$POP_DECOMPTYPE");
add_default($nl, 'ew_boundary_type');
add_default($nl, 'ns_boundary_type');
add_default($nl, 'profile_barrier');

##################################
# namelist group: io_nml         #
##################################

add_default($nl, 'num_iotasks');
add_default($nl, 'lredirect_stdout');
add_default($nl, 'log_filename', 'val'=>"${RUNDIR}/ocn${inst_string}.log.$LID");
add_default($nl, 'luse_pointer_files');

####################################
# namelist group: time_manager_nml #
####################################

add_default($nl, 'accel_file', 'val'=>"${RUNDIR}/${OCN_GRID}_depth_accel");
add_default($nl, 'runid', 'val'=>"$CASE");
add_default($nl, 'time_mix_opt');
add_default($nl, 'time_mix_freq');
add_default($nl, 'dt_option');

my $time_mix_opt = $nl->get_value('time_mix_opt');
$time_mix_opt =~ s/^\s+//;
$time_mix_opt =~ s/\s+$//;
add_default($nl, 'dt_count','ocn_coupling'=>"$OCN_COUPLING",'ocn_onedim'=>"$OCN_ONEDIM", 'time_mix'=>"$time_mix_opt");

add_default($nl, 'impcor');
add_default($nl, 'laccel');
add_default($nl, 'dtuxcel');
add_default($nl, 'allow_leapyear', 'calendar'=>"$CALENDAR");
add_default($nl, 'iyear0'  ,'val'=>$iyear0);
add_default($nl, 'imonth0' ,'val'=>$imonth0);
add_default($nl, 'iday0'   ,'val'=>$iday0);
add_default($nl, 'ihour0'  ,'val'=>$ihour0);
add_default($nl, 'iminute0','val'=>$iminute0);
add_default($nl, 'isecond0','val'=>$isecond0);
add_default($nl, 'date_separator');
add_default($nl, 'stop_option');
add_default($nl, 'stop_count');
add_default($nl, 'fit_freq', 'val'=>"$OCN_NCPL");
add_default($nl, 'robert_alpha');
add_default($nl, 'robert_nu');

####################################
# namelist group: grid_nml #
####################################

# Note: topography_opt = bathymetry is a nonstandard option that
# requires the user to provide nonstandard files in the users'
# $CASEROOT/SourceMods/src.pop directory
# Currently this is hard-wired to 'file'

# Also, flat_bottom is not set until after pop1d_nml because its
# default value depends on lidentical_columns

my $topography_opt = 'file';               # hard-wired for now
my $bathymetry_file= 'unknown_bathymetry'; #hard-wired for now

add_default($nl, 'vert_grid_file'  , 'val'=>"${RUNDIR}/${OCN_GRID}_vert_grid");
add_default($nl, 'region_info_file', 'val'=>"${RUNDIR}/${OCN_GRID}_region_ids");
add_default($nl, 'topography_opt'  , 'val'=>"$topography_opt");
add_default($nl, 'bathymetry_file' , 'val'=>"$bathymetry_file");
add_default($nl, 'lremove_points'  , 'topograpahy_opt'=>"$topography_opt");
add_default($nl, 'horiz_grid_opt');
add_default($nl, 'horiz_grid_file');
add_default($nl, 'vert_grid_opt' );
add_default($nl, 'topography_file');
add_default($nl, 'topography_outfile', 'val'=>"${output_h}.topography_bathymetry.ieeer8");
add_default($nl, 'kmt_kmin');
add_default($nl, 'partial_bottom_cells');
add_default($nl, 'bottom_cell_file', 'nofail'=>1);
if (not $nl->get_value('bottom_cell_file')) {
	add_default($nl, 'bottom_cell_file', 'val'=>'unknown_bottom_cell','noprepend'=>1);
}
add_default($nl, 'n_topo_smooth');
add_default($nl, 'region_mask_file');
add_default($nl, 'sfc_layer_opt', 'ocn_onedim'=>"$OCN_ONEDIM");

add_default($nl, 'l1Ddyn', 'ocn_onedim'=>"$OCN_ONEDIM");


####################################
# namelist group: pop1d_nml #
####################################

my $iden_cols = 'FALSE'; # used for constant Coriolis and flat bottom
my $l1Ddyn = $nl->get_value('l1Ddyn');
if ($l1Ddyn eq '.true.') {
  add_default($nl, 'lidentical_columns');
  my $lidentical_cols = $nl->get_value('lidentical_columns');
  if ($lidentical_cols eq '.true.') {
    $iden_cols = 'TRUE';
  }
  add_default($nl, 'lconst_Coriolis', 'iden_cols'=>"$iden_cols");
  add_default($nl, 'lmin_Coriolis', 'ocn_onedim'=>"$OCN_ONEDIM");
  add_default($nl, 'Coriolis_min');
  add_default($nl, 'Coriolis_val');
  add_default($nl, 'global_taux');
  add_default($nl, 'global_SHF_coef');
}

# Back to grid_nml
add_default($nl, 'flat_bottom', 'iden_cols'=>"$iden_cols");

####################################
# namelist group: init_ts_nml      #
####################################

if ($OCN_ONEDIM eq 'TRUE' && $RUN_TYPE eq 'startup') {
  add_default($nl, 'init_ts_option', 'val'=>'internal');
} else {

  if ($RUN_TYPE eq 'startup' && $topography_opt eq 'bathymetry') {
    add_default($nl, 'init_ts_option'  , 'val'=>'PHC');
    add_default($nl, 'init_ts_file'    , 'val'=>'ts_PHC2_jan_ic_resindpt'); #TODO?
    add_default($nl, 'init_ts_file_fmt', 'val'=>'nc');
  } else {
    add_default($nl, 'init_ts_option'  , 'val'=>"ccsm_${RUN_TYPE}");
    add_default($nl, 'init_ts_file');
    if ($OCN_GRID eq 'tx0.1v3') {
      add_default($nl, 'init_ts_file_fmt');
    } else {
      add_default($nl, 'init_ts_file_fmt', 'val'=>"$RESTART_INPUT_TS_FMT");
    }
  }
}
add_default($nl, 'init_ts_outfile'     , 'val'=>"${output_h}.ts_ic");
add_default($nl, 'init_ts_outfile_fmt');
add_default($nl, 'init_ts_suboption');
add_default($nl, 'init_ts_perturb');

##########################################
# namelist group: diagnostics_nml        #
##########################################

add_default($nl, 'diag_transport_file', 'val'=>"${RUNDIR}/${OCN_GRID}_transport_contents");
if ($INFO_DBUG > 1) {
    add_default($nl, 'diag_global_freq_opt', 'val'=>'nstep');
    add_default($nl, 'diag_cfl_freq_opt'   , 'val'=>'nstep');
    add_default($nl, 'diag_transp_freq_opt', 'val'=>'nstep');
} else {
    add_default($nl, 'diag_global_freq_opt');
    add_default($nl, 'diag_cfl_freq_opt');
    add_default($nl, 'diag_transp_freq_opt');
}
add_default($nl, 'diag_global_freq');
add_default($nl, 'diag_cfl_freq');
add_default($nl, 'diag_transp_freq');
add_default($nl, 'diag_outfile',          'val'=>"${RUNDIR}/${output_d}d");
add_default($nl, 'diag_transport_outfile','val'=>"${RUNDIR}/${output_d}t");
add_default($nl, 'diag_velocity_outfile', 'val'=>"${RUNDIR}/${output_d}v");
add_default($nl, 'cfl_all_levels');
add_default($nl, 'diag_all_levels');
add_default($nl, 'ldiag_velocity');

##########################################
# namelist group: budget_diagnostics_nml #
##########################################

if ($OCN_TAVG_HIFREQ eq "TRUE" ) {
    add_default($nl, 'ldiag_global_tracer_budgets', 'val'=>'.false.');
} else {
    add_default($nl, 'ldiag_global_tracer_budgets','ocn_onedim'=>"$OCN_ONEDIM");
}

##########################################
# namelist group: bsf_diagnostics_nml    #
##########################################

add_default($nl, 'ldiag_bsf', 'ocn_onedim'=>"$OCN_ONEDIM");

##########################################
# namelist group: restart_nml            #
##########################################

add_default($nl, 'restart_freq_opt');
add_default($nl, 'restart_freq');
add_default($nl, 'restart_start_opt');
add_default($nl, 'restart_start');
add_default($nl, 'restart_outfile', 'val'=>"${output_r}");
add_default($nl, 'restart_fmt');
add_default($nl, 'leven_odd_on');
add_default($nl, 'even_odd_freq');
add_default($nl, 'pressure_correction');

##########################################
# namelist group: history_nml            #
##########################################

add_default($nl, 'history_contents', 'val'=>"${RUNDIR}/${OCN_GRID}_history_contents");
add_default($nl, 'history_freq_opt');
add_default($nl, 'history_freq');
add_default($nl, 'history_outfile', 'val'=>"${output_h}s");
add_default($nl, 'history_fmt');

##########################################
# namelist group: movie_nml              #
##########################################

add_default($nl, 'movie_contents', 'val'=>"${RUNDIR}/${OCN_GRID}_movie_contents");
add_default($nl, 'movie_freq_opt');
add_default($nl, 'movie_freq');
add_default($nl, 'movie_outfile', 'val'=>"${output_h}m");
add_default($nl, 'movie_fmt');

##########################################
# namelist group: solvers                #
##########################################

add_default($nl, 'solverChoice');
add_default($nl, 'convergenceCriterion');
add_default($nl, 'maxIterations');
add_default($nl, 'convergenceCheckFreq');
add_default($nl, 'convergenceCheckStart');
add_default($nl, 'preconditionerChoice');
add_default($nl, 'preconditionerFile');
add_default($nl, 'lanczosconvergenceCriterion');
add_default($nl, 'maxLanczosStep');

##########################################
# namelist group: vertical_mix_nml       #
##########################################

add_default($nl, 'vmix_choice');
add_default($nl, 'aidif');
add_default($nl, 'implicit_vertical_mix');
add_default($nl, 'convection_type');
add_default($nl, 'nconvad');
add_default($nl, 'convect_diff');
add_default($nl, 'convect_visc');
add_default($nl, 'bottom_drag');

########################################
# namelist group: geoheatflux_nml      #
########################################

add_default($nl, 'geoheatflux_choice');
add_default($nl, 'geoheatflux_const');
add_default($nl, 'geoheatflux_depth');

##########################################
# namelist group: vmix_const_nml         #
##########################################

add_default($nl, 'const_vvc');
add_default($nl, 'const_vdc');

##########################################
# namelist group: vmix_rich_nml         #
##########################################

add_default($nl, 'bckgrnd_vvc');
add_default($nl, 'bckgrnd_vdc');
add_default($nl, 'rich_mix&vmix_rich_nml');

##########################################
# namelist group: tidal_nml              #
##########################################

add_default($nl, 'ltidal_all_TC_coefs_eq_1');
add_default($nl, 'ltidal_all_TC_coefs_eq_p33');
add_default($nl, 'ltidal_mixing');
   my $ltidal_mixing = $nl->get_value('ltidal_mixing');
   $ltidal_mixing =~ s/ //g;
add_default($nl, 'ltidal_max');
add_default($nl, 'ltidal_schmittner_socn');
add_default($nl, 'ltidal_stabc');
add_default($nl, 'ltidal_lunar_cycle');
add_default($nl, 'ltidal_melet_plot');
   my $ltidal_melet_plot = $nl->get_value('ltidal_melet_plot');
   $ltidal_melet_plot =~ s/ //g;
add_default($nl, 'tidal_energy_choice');
   my $tidal_energy_choice = $nl->get_value('tidal_energy_choice');
   $tidal_energy_choice =~ s/ //g;
if ($ltidal_mixing eq ".true." ) {
  add_default($nl, 'tidal_energy_file',    'tidal_energy_choice'=>"$tidal_energy_choice");
  add_default($nl, 'tidal_energy_file_fmt','tidal_energy_choice'=>"$tidal_energy_choice");
}
add_default($nl, 'tidal_eps_n2');
add_default($nl, 'tidal_vars_file_polz', 'nofail'=>1);
if (not $nl->get_value('tidal_vars_file_polz')) {
        add_default($nl, 'tidal_vars_file_polz', 'val'=>'unknown_tidal_vars_file_polz','noprepend'=>1);
}
add_default($nl, 'tidal_energy_ts_files(1)');
add_default($nl, 'tidal_energy_ts_files(2)');
add_default($nl, 'tidal_energy_ts_files(3)');
add_default($nl, 'tidal_energy_ts_files(4)');
add_default($nl, 'tidal_energy_ts_file_fmt');
add_default($nl, 'tidal_energy_ts_calendar');
add_default($nl, 'tidal_energy_ts_model_yr_align');
add_default($nl, 'tidal_energy_ts_data_first_year');
add_default($nl, 'tidal_energy_ts_data_first_month');
add_default($nl, 'tidal_energy_ts_data_first_day');
add_default($nl, 'tidal_energy_ts_data_final_year');
add_default($nl, 'tidal_energy_ts_data_final_month');
add_default($nl, 'tidal_energy_ts_data_final_day');
add_default($nl, 'tidal_local_mixing_fraction');
add_default($nl, 'tidal_mixing_method_choice');
   my $tidal_mixing_method_choice = $nl->get_value('tidal_mixing_method_choice');
   $tidal_mixing_method_choice =~ s/ //g;
add_default($nl, 'tidal_mixing_efficiency');
add_default($nl, 'vertical_decay_scale');
add_default($nl, 'tidal_mix_max');
add_default($nl, 'tidal_diss_lim_TC');
add_default($nl, 'tidal_vars_file_fmt_polz');
add_default($nl, 'tidal_vert_decay_option_schm');

add_default($nl,'ltidal_min_regions');
add_default($nl,'num_tidal_min_regions');
add_default($nl,'tidal_min_values(1)');
add_default($nl,'tidal_min_regions_name(1)');
add_default($nl,'tidal_min_regions_klevels(1)');
add_default($nl,'tidal_TLATmin_regions(1)');
add_default($nl,'tidal_TLATmax_regions(1)');
add_default($nl,'tidal_TLONmin_regions(1)');
add_default($nl,'tidal_TLONmax_regions(1)');
add_default($nl,'tidal_min_values(2)');
add_default($nl,'tidal_min_regions_name(2)');
add_default($nl,'tidal_min_regions_klevels(2)');
add_default($nl,'tidal_TLATmin_regions(2)');
add_default($nl,'tidal_TLATmax_regions(2)');
add_default($nl,'tidal_TLONmin_regions(2)');
add_default($nl,'tidal_TLONmax_regions(2)');
add_default($nl,'tidal_min_values(3)');
add_default($nl,'tidal_min_regions_name(3)');
add_default($nl,'tidal_min_regions_klevels(3)');
add_default($nl,'tidal_TLATmin_regions(3)');
add_default($nl,'tidal_TLATmax_regions(3)');
add_default($nl,'tidal_TLONmin_regions(3)');
add_default($nl,'tidal_TLONmax_regions(3)');

##########################################
# namelist group: vmix_kpp_nml           #
##########################################

add_default($nl, 'lcvmix', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl, 'rich_mix&vmix_kpp_nml');

# grid dependent value of lhoriz_varying_background set in
# namelist_defaults_pop.xml and value of ltidal-mixing is
# obtained from default value already set

my $ltidal_mixing = $nl->get_value('ltidal_mixing');
$ltidal_mixing =~ s/ //g;

add_default($nl, 'lhoriz_varying_bckgrnd', 'ocn_onedim'=>"$OCN_ONEDIM");
my $lhoriz_varying_bckgrnd= $nl->get_value('lhoriz_varying_bckgrnd');
$lhoriz_varying_bckgrnd =~ s/ //g;

add_default($nl, 'linertial');
add_default($nl, 'Prandtl');
add_default($nl, 'lrich');
add_default($nl, 'ldbl_diff');
add_default($nl, 'lshort_wave');
add_default($nl, 'lcheckekmo');
add_default($nl, 'larctic_bckgrnd_vdc');
add_default($nl, 'num_v_smooth_Ri');

add_default($nl, 'bckgrnd_vdc1',     'lhoriz_varying_bckgrnd'=>"$lhoriz_varying_bckgrnd", 'ltidal_mixing'=>"$ltidal_mixing");
add_default($nl, 'bckgrnd_vdc2',     'lhoriz_varying_bckgrnd'=>"$lhoriz_varying_bckgrnd", 'ltidal_mixing'=>"$ltidal_mixing");
add_default($nl, 'bckgrnd_vdc_dpth', 'lhoriz_varying_bckgrnd'=>"$lhoriz_varying_bckgrnd", 'ltidal_mixing'=>"$ltidal_mixing");
add_default($nl, 'bckgrnd_vdc_eq',   'lhoriz_varying_bckgrnd'=>"$lhoriz_varying_bckgrnd", 'ltidal_mixing'=>"$ltidal_mixing");
add_default($nl, 'bckgrnd_vdc_psim', 'lhoriz_varying_bckgrnd'=>"$lhoriz_varying_bckgrnd", 'ltidal_mixing'=>"$ltidal_mixing");
add_default($nl, 'bckgrnd_vdc_ban',  'lhoriz_varying_bckgrnd'=>"$lhoriz_varying_bckgrnd", 'ltidal_mixing'=>"$ltidal_mixing");
add_default($nl, 'bckgrnd_vdc_linv');
# QL, 150526, langmuir_opt
add_default($nl, 'langmuir_opt');

##########################################
# namelist group: advect_nml             #
##########################################

add_default($nl, 'tadvect_ctype');

##########################################
# namelist group: hmix_nml               #
##########################################

add_default($nl, 'hmix_momentum_choice');
add_default($nl, 'hmix_tracer_choice');
add_default($nl, 'lsubmesoscale_mixing');

##########################################
# namelist group: hmix_del2u_nml         #
##########################################

add_default($nl, 'lauto_hmix&hmix_del2u_nml');

add_default($nl, 'lvariable_hmix&hmix_del2u_nml');

add_default($nl, 'am&hmix_del2u_nml');

##########################################
# namelist group: hmix_del2t_nml         #
##########################################

add_default($nl, 'lauto_hmix&hmix_del2t_nml');

add_default($nl, 'lvariable_hmix&hmix_del2t_nml');

add_default($nl, 'ah&hmix_del2t_nml');

##########################################
# namelist group: hmix_del4u_nml         #
##########################################

add_default($nl, 'lauto_hmix&hmix_del4u_nml');

add_default($nl, 'lvariable_hmix&hmix_del4u_nml');

add_default($nl, 'am&hmix_del4u_nml');

##########################################
# namelist group: hmix_del4t_nml         #
##########################################

add_default($nl, 'lauto_hmix&hmix_del4t_nml');

add_default($nl, 'lvariable_hmix&hmix_del4t_nml');

add_default($nl, 'ah&hmix_del4t_nml');

##########################################
# namelist group: hmix_gm_nml            #
##########################################

add_default($nl, 'kappa_isop_choice');
add_default($nl, 'kappa_thic_choice');

add_default($nl, 'kappa_isop_deep');
add_default($nl, 'kappa_thic_deep');

# All namelist values are stored in exactly the format
# that is required in a valid namelist.  So if that value
# is a string, then the quotes are stored as part of the value.

my $kappa_isop_choice = $nl->get_value('kappa_isop_choice');
my $kappa_thic_choice = $nl->get_value('kappa_thic_choice');
$kappa_isop_choice =~ s/[\'\"]//g;
$kappa_thic_choice =~ s/[\'\"]//g;

# note that ah_gm_value is explicitly put below since ah is
# contained in several namelist variables

add_default($nl, 'ah_bolus'    ,
                 'kappa_isop_choice'=>"$kappa_isop_choice",
                 'kappa_thic_choice'=>"$kappa_thic_choice");
add_default($nl, 'ah_bkg_srfbl',
                 'kappa_isop_choice'=>"$kappa_isop_choice",
                 'kappa_thic_choice'=>"$kappa_thic_choice");
add_default($nl, 'use_const_ah_bkg_srfbl',
                 'kappa_isop_choice'=>"$kappa_isop_choice",
                 'kappa_thic_choice'=>"$kappa_thic_choice");
add_default($nl, 'ah&hmix_gm_nml',
                 'kappa_isop_choice'=>"$kappa_isop_choice",
                 'kappa_thic_choice'=>"$kappa_thic_choice");

# note that ocn_grid dependence for ah_bolus, ah_bkg_srfbl
# is obtained from config_cache.xml

add_default($nl, 'buoyancy_freq_filename', 'val'=>"${RUNDIR}/buoyancy_freq");
add_default($nl, 'diag_gm_bolus','ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl, 'kappa_freq_choice');
add_default($nl, 'slope_control_choice');
add_default($nl, 'kappa_depth_1');
add_default($nl, 'kappa_depth_2');
add_default($nl, 'kappa_depth_scale');
add_default($nl, 'ah_bkg_bottom');
add_default($nl, 'slm_r');
add_default($nl, 'slm_b');
add_default($nl, 'transition_layer_on');
add_default($nl, 'read_n2_data');
add_default($nl, 'buoyancy_freq_fmt');
add_default($nl, 'const_eg');
add_default($nl, 'gamma_eg');
add_default($nl, 'kappa_min_eg');
add_default($nl, 'kappa_max_eg');

##########################################
# namelist group: hmix_gm_aniso_nml      #
##########################################

add_default($nl, 'kdir_type_choice');
add_default($nl, 'krat_type_choice');
add_default($nl, 'kmin_type_choice');

# All namelist values are stored in exactly the format
# that is required in a valid namelist.  So if that value
# is a string, then the quotes are stored as part of the value.

my $kdir_type_choice = $nl->get_value('kdir_type_choice');
my $krat_type_choice = $nl->get_value('krat_type_choice');
my $kmin_type_choice = $nl->get_value('kmin_type_choice');
$kdir_type_choice =~ s/[\'\"]//g;
$krat_type_choice =~ s/[\'\"]//g;
$kmin_type_choice =~ s/[\'\"]//g;
add_default($nl, 'efficiency_factor');
add_default($nl, 'addrandfluc');
add_default($nl, 'cflmajoronly');
add_default($nl, 'cflmult');
add_default($nl, 'erat_const');
add_default($nl, 'erat_factor');
add_default($nl, 'isominoronly');
add_default($nl, 'isoonly');
add_default($nl, 'kdir_type_choice');
add_default($nl, 'kmin_type_choice');
add_default($nl, 'krat_type_choice');
add_default($nl, 'minorfactor');
add_default($nl, 'savenewtavgs');
add_default($nl, 'shrdispfac');
add_default($nl, 'simpsubcells');
add_default($nl, 'vertdiffhere');

##########################################
# namelist group: mix_submeso_nml        #
##########################################

add_default($nl, 'efficiency_factor');
add_default($nl, 'time_scale_constant');
add_default($nl, 'luse_const_horiz_len_scale');
add_default($nl, 'hor_length_scale');

##########################################
# namelist group: hmix_aniso_nml         #
##########################################

add_default($nl, 'hmix_alignment_choice');
add_default($nl, 'lvariable_hmix_aniso');
add_default($nl, 'lsmag_aniso');
add_default($nl, 'visc_para');
add_default($nl, 'visc_perp');
add_default($nl, 'c_para');
add_default($nl, 'c_perp');
add_default($nl, 'u_para');
add_default($nl, 'u_perp');
add_default($nl, 'vconst_1');
add_default($nl, 'vconst_2');
add_default($nl, 'vconst_3');
add_default($nl, 'vconst_4');
add_default($nl, 'vconst_5');
add_default($nl, 'vconst_6');
add_default($nl, 'vconst_7');
add_default($nl, 'smag_lat');
add_default($nl, 'smag_lat_fact');
add_default($nl, 'smag_lat_gauss');
add_default($nl, 'var_viscosity_infile');
add_default($nl, 'var_viscosity_infile_fmt');
add_default($nl, 'var_viscosity_outfile', 'val'=>"${output_h}v");
add_default($nl, 'var_viscosity_outfile_fmt');

##########################################
# namelist group: state_nml              #
##########################################

add_default($nl, 'state_choice');
add_default($nl, 'state_file');
add_default($nl, 'state_range_opt');
add_default($nl, 'state_range_freq');

##########################################
# namelist group: baroclinic_nml         #
##########################################

add_default($nl, 'reset_to_freezing');

##########################################
# namelist group: ice_nml                #
##########################################

add_default($nl,'lactive_ice', 'ocn_ice_forcing'=>"$OCN_ICE_FORCING");
add_default($nl,'ice_freq_opt');
add_default($nl,'ice_freq');
add_default($nl,'licecesm2');
add_default($nl,'kmxice');

##########################################
# namelist group: pressure_grad_nml      #
##########################################

add_default($nl,'lpressure_avg');
add_default($nl,'lbouss_correct');

##########################################
# namelist group: topostress_nml         #
##########################################

add_default($nl,'ltopostress');
add_default($nl,'nsmooth_topo');

##########################################
# namelist group: damping_nml            #
##########################################

add_default($nl, 'ldamp_uv', 'ocn_onedim'=>"$OCN_ONEDIM");

##########################################
# namelist group: forcing_ws_nml         #
##########################################

add_default($nl,'ws_data_renorm');
add_default($nl,'ws_data_type');
add_default($nl,'ws_data_inc');
add_default($nl,'ws_interp_freq');
add_default($nl,'ws_interp_type');
add_default($nl,'ws_interp_inc');
add_default($nl,'ws_filename');
add_default($nl,'ws_file_fmt');

##########################################
# namelist group: forcing_shf_nml        #
##########################################

add_default($nl,'shf_formulation','ocn_coupling'=>"$OCN_COUPLING");
add_default($nl,'shf_data_type'  ,'ocn_coupling'=>"$OCN_COUPLING");
add_default($nl,'luse_cpl_ifrac' ,'ocn_coupling'=>"$OCN_COUPLING");
add_default($nl,'shf_data_inc');
add_default($nl,'shf_interp_freq');
add_default($nl,'shf_interp_type');
add_default($nl,'shf_interp_inc');
add_default($nl,'shf_restore_tau');
add_default($nl,'shf_filename');
add_default($nl,'shf_file_fmt');
add_default($nl,'shf_data_renorm(3)');
add_default($nl,'shf_weak_restore', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'shf_strong_restore', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'shf_strong_restore_ms', 'ocn_onedim'=>"$OCN_ONEDIM");

##########################################
# namelist_group: forcing_sfwf_nml       #
##########################################

add_default($nl,'sfwf_formulation' , 'ocn_coupling'=>"$OCN_COUPLING");
add_default($nl,'sfwf_data_type'   , 'ocn_coupling'=>"$OCN_COUPLING");
add_default($nl,'ladjust_precip'   , 'ocn_coupling'=>"$OCN_COUPLING", 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'lms_balance'      , 'ocn_coupling'=>"$OCN_COUPLING", 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'lsend_precip_fact', 'ocn_coupling'=>"$OCN_COUPLING", 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'sfwf_data_inc');
add_default($nl,'sfwf_interp_freq');
add_default($nl,'sfwf_interp_type');
add_default($nl,'sfwf_interp_inc');
add_default($nl,'sfwf_restore_tau');
add_default($nl,'sfwf_filename', 'ocn_transient'=>"$OCN_TRANSIENT");
add_default($nl,'sfwf_file_fmt');
add_default($nl,'sfwf_data_renorm');
add_default($nl,'sfwf_strong_restore', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'sfwf_strong_restore_ms', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'sfwf_weak_restore', 'ocn_onedim'=>"$OCN_ONEDIM", 'ocn_transient'=>"$OCN_TRANSIENT");
add_default($nl,'lfw_as_salt_flx');
add_default($nl,'precip_fact_const');

##########################################
# namelist group: forcing_pt_interior_nml#
##########################################

add_default($nl,'pt_interior_data_type');
add_default($nl,'pt_interior_data_inc');
add_default($nl,'pt_interior_interp_freq');
add_default($nl,'pt_interior_interp_type');
add_default($nl,'pt_interior_interp_inc');
add_default($nl,'pt_interior_restore_tau');
add_default($nl,'pt_interior_filename');
add_default($nl,'pt_interior_file_fmt');
add_default($nl,'pt_interior_restore_max_level');
add_default($nl,'pt_interior_formulation');
add_default($nl,'pt_interior_data_renorm');
add_default($nl,'pt_interior_variable_restore');
add_default($nl,'pt_interior_restore_filename');
add_default($nl,'pt_interior_restore_file_fmt');
add_default($nl,'pt_interior_surface_restore', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'pt_interior_shr_stream_year_first');
add_default($nl,'pt_interior_shr_stream_year_last');
add_default($nl,'pt_interior_shr_stream_year_align');
add_default($nl,'pt_interior_shr_stream_file');

##########################################
# namelist group: forcing_s_interior_nml #
##########################################

add_default($nl,'s_interior_data_type');
add_default($nl,'s_interior_data_inc');
add_default($nl,'s_interior_interp_freq');
add_default($nl,'s_interior_interp_type');
add_default($nl,'s_interior_interp_inc');
add_default($nl,'s_interior_restore_tau');
add_default($nl,'s_interior_filename');
add_default($nl,'s_interior_file_fmt');
add_default($nl,'s_interior_restore_max_level');
add_default($nl,'s_interior_formulation');
add_default($nl,'s_interior_data_renorm');
add_default($nl,'s_interior_variable_restore');
add_default($nl,'s_interior_restore_filename');
add_default($nl,'s_interior_restore_file_fmt');
add_default($nl,'s_interior_surface_restore', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'s_interior_shr_stream_year_first');
add_default($nl,'s_interior_shr_stream_year_last');
add_default($nl,'s_interior_shr_stream_year_align');
add_default($nl,'s_interior_shr_stream_file');

##########################################
# namelist group: forcing_ap_interior_nml#
##########################################

add_default($nl,'ap_data_type');
add_default($nl,'ap_data_inc');
add_default($nl,'ap_interp_freq');
add_default($nl,'ap_interp_type');
add_default($nl,'ap_interp_inc');
add_default($nl,'ap_filename');
add_default($nl,'ap_file_fmt');
add_default($nl,'ap_data_renorm');

##########################################
# namelist group: coupled_nml            #
##########################################

# $coupled_freq and $coupled_freq_opts are computed after reading XML vars
add_default($nl,'coupled_freq',val=>"$coupled_freq");
add_default($nl,'coupled_freq_opt', val=>"$coupled_freq_opt");
add_default($nl,'qsw_distrb_opt', 'ocn_coupling'=>"$OCN_COUPLING");

##########################################
# namelist group: sw_absorption_nml      #
##########################################

add_default($nl,'sw_absorption_type', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'chl_option', 'ocn_chl_type'=>"$OCN_CHL_TYPE");
add_default($nl,'chl_filename');
add_default($nl,'chl_file_fmt');
add_default($nl,'jerlov_water_type');

##########################################
# namelist group: transports_nml         #
##########################################

my @transport_reg2_names = ("'Atlantic Ocean'",',',
                            "'Mediterranean Sea'",',',
                            "'Labrador Sea'",',',
                            "'GIN Sea'",',',
                            "'Arctic Ocean'",',',
                            "'Hudson Bay'");

add_default($nl,'lat_aux_grid_type');
add_default($nl,'lat_aux_begin');
add_default($nl,'lat_aux_end');
add_default($nl,'n_lat_aux_grid');
add_default($nl,'moc_requested','ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'n_heat_trans_requested','ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'n_salt_trans_requested','ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'transport_reg2_names', 'val'=>"@transport_reg2_names");
add_default($nl,'n_transport_reg');

##########################################
# namelist group: context_nml            #
##########################################

add_default($nl,'lcoupled');
add_default($nl,'lccsm');
add_default($nl,'b4b_flag');
add_default($nl,'lccsm_control_compatible');
add_default($nl,'ldebug', 'DEBUG'=>"$DEBUG");

##########################################
# namelist group: overflows_nml          #
##########################################

if ($OCN_GRID =~ /^gx*/) {
  add_default($nl,'overflows_infile',  'val'=>"${RUNDIR}/${OCN_GRID}_overflow");
} else {
	add_default($nl, 'overflows_infile', 'val'=>'unknown_overflow','noprepend'=>1);
}

add_default($nl,'overflows_on', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'overflows_interactive', 'ocn_onedim'=>"$OCN_ONEDIM");
add_default($nl,'overflows_diag_outfile', 'val'=>"${RUNDIR}/${output_d}o");
add_default($nl,'overflows_restart_type', 'val'=>"ccsm_${RUN_TYPE}");
add_default($nl,'overflows_restfile'    , 'val'=>"${output_r}o");

##########################################
# namelist group: niw_nml                #
##########################################

add_default($nl,'lniw_mixing');
   my $lniw_mixing = $nl->get_value('lniw_mixing');
   $lniw_mixing =~ s/ //g;
add_default($nl,'niw_local_mixing_fraction');
add_default($nl,'niw_mixing_efficiency');
add_default($nl,'niw_obs2model_ratio');
add_default($nl,'niw_boundary_layer_absorption');
add_default($nl,'niw_vert_decay_scale');
add_default($nl,'niw_mix_max');
add_default($nl,'niw_energy_type');
add_default($nl,'niw_energy_file_fmt');
add_default($nl,'niw_energy_file', 'nofail'=>1);
if (not $nl->get_value('niw_energy_file')) {
	add_default($nl, 'niw_energy_file', 'val'=>'unknown_niw_energy','noprepend'=>1);
}

##########################################
# namelist group: se_nml                 #
##########################################

add_default($nl, "lchange_ans");

##########################################
# namelist group: passive_tracers_on_nml #
##########################################

add_default($nl, "iage_on");
add_default($nl, "cfc_on");
add_default($nl, "sf6_on");
add_default($nl, "abio_dic_dic14_on");
add_default($nl, "ecosys_on");
add_default($nl, "irf_on");

##########################################
### namelist group: estuary_nml            #
############################################
add_default($nl, 'estuary_option');
add_default($nl, 'estuary_type');
add_default($nl, 'ebm_param_option');
add_default($nl, 'ebm_param_filename', 'rof_grid'=>"$ROF_GRID", 'nofail'=>1);
if (not $nl->get_value('ebm_param_filename')) {
	add_default($nl, 'ebm_param_filename', 'val'=>'unknown_ebm_param_filename','noprepend'=>1);
}
add_default($nl, 'ebm_param_file_fmt');
add_default($nl, 'tide_amp');
add_default($nl, 'W_h');
add_default($nl, 'H');
add_default($nl, 'a1');
add_default($nl, 'a2');
add_default($nl, 'h0');
add_default($nl, 'h_upper');
add_default($nl, 'h_lower');

##########################################
# namelist group: iage_nml               #
##########################################

my $iage_on = $cfg->get("use_iage");
if ($iage_on eq "TRUE") {
    if ($POP_PASSIVE_TRACER_RESTART_OVERRIDE eq "none") {
      add_default($nl, 'init_iage_option',    'val'=>"ccsm_${RUN_TYPE}");
      add_default($nl, 'init_iage_init_file', 'val'=>'same_as_TS', 'noprepend'=>1);
    } else {
      add_default($nl, 'init_iage_option',    'val'=>"ccsm_hybrid");
      add_default($nl, 'init_iage_init_file', 'val'=>"$POP_PASSIVE_TRACER_RESTART_OVERRIDE", 'noprepend'=>1);
      add_default($nl, 'init_iage_init_file_fmt', 'val'=>'nc');
    }
}

##########################################
# namelist group: cfc_nml                #
##########################################

my $cfc_on = $cfg->get("use_cfc");
if ($cfc_on eq "TRUE") {
    add_default($nl, 'model_year&cfc_nml', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'data_year&cfc_nml' , 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'pcfc_first_nonzero_year');

    # If RUN_TYPE=startup, CONTINUE_RUN=FALSE, and the effective cfc year >= pcfc_first_nonzero_year
    # then make the user specify init_cfc_option.

    if ($RUN_TYPE eq "startup") {
      # RUN_TYPE gets changed to continue if CONTINUE_RUN eq "TRUE",
      # so we may assume here that CONTINUE_RUN eq "FALSE"

      my @START_ARRAY = split('-',$RUN_STARTDATE);
      my $START_YEAR = @START_ARRAY[0];

      my $cfc_model_year = $nl->get_value("model_year&cfc_nml");
      my $cfc_data_year  = $nl->get_value("data_year&cfc_nml");
      my $START_YEAR_adj = $START_YEAR - $cfc_model_year + $cfc_data_year;
      my $pcfc_first_nonzero_year = $nl->get_value("pcfc_first_nonzero_year");

      if ($START_YEAR_adj ge $pcfc_first_nonzero_year) {
        # Abort if init_cfc_option was not set in user_nl_pop
        if ($nl->get_variable_value("cfc_nml", "init_cfc_option") eq "") {
          print "RUN_TYPE=startup\n",
                "START_YEAR_adj=$START_YEAR_adj ge pcfc_first_nonzero_year=$pcfc_first_nonzero_year\n",
                "ERROR: CFCs cannot be automatically initialized post $pcfc_first_nonzero_year in a startup run\n",
                "Set init_cfc_option or change pcfc_first_nonzero_year in user_nl_pop.\n";
          die;
        }
      }
    }

    add_default($nl, 'init_cfc_option', 'val'=>"ccsm_$RUN_TYPE");

    add_default($nl, 'cfc_formulation');
    add_default($nl, 'pcfc_file');
    add_default($nl, 'init_cfc_init_file', 'noprepend'=>1);
}

##########################################
# namelist group: sf6_nml                #
##########################################

my $sf6_on = $cfg->get("use_sf6");
if ($sf6_on eq "TRUE") {
    add_default($nl, 'model_year&sf6_nml', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'data_year&sf6_nml' , 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'psf6_first_nonzero_year');

    # If RUN_TYPE=startup, CONTINUE_RUN=FALSE, and the effective sf6 year >= psf6_first_nonzero_year
    # then make the user specify init_sf6_option.

    if ($RUN_TYPE eq "startup") {
      # RUN_TYPE gets changed to continue if CONTINUE_RUN eq "TRUE",
      # so we may assume here that CONTINUE_RUN eq "FALSE"

      my @START_ARRAY = split('-',$RUN_STARTDATE);
      my $START_YEAR = @START_ARRAY[0];

      my $sf6_model_year = $nl->get_value("model_year&sf6_nml");
      my $sf6_data_year  = $nl->get_value("data_year&sf6_nml");
      my $START_YEAR_adj = $START_YEAR - $sf6_model_year + $sf6_data_year;
      my $psf6_first_nonzero_year = $nl->get_value("psf6_first_nonzero_year");

      if ($START_YEAR_adj ge $psf6_first_nonzero_year) {
        # Abort if init_sf6_option was not set in user_nl_pop
        if ($nl->get_variable_value("sf6_nml", "init_sf6_option") eq "") {
          print "RUN_TYPE=startup\n",
                "START_YEAR_adj=$START_YEAR_adj ge psf6_first_nonzero_year=$psf6_first_nonzero_year\n",
                "ERROR: sf6s cannot be automatically initialized post $psf6_first_nonzero_year in a startup run\n",
                "Set init_sf6_option or change psf6_first_nonzero_year in user_nl_pop.\n";
          die;
        }
      }
    }

    add_default($nl, 'init_sf6_option', 'val'=>"ccsm_$RUN_TYPE");

    add_default($nl, 'sf6_formulation');
    add_default($nl, 'psf6_file');
    add_default($nl, 'init_sf6_init_file', 'noprepend'=>1);
}

##########################################
# namelist group: abio_dic_dic14_nml               #
##########################################

my $abio_on = $cfg->get("use_abio");
if ($abio_on eq "TRUE") {

    if ($POP_PASSIVE_TRACER_RESTART_OVERRIDE eq "none") {
      add_default($nl, 'init_abio_dic_dic14_option', 'val'=>"ccsm_${RUN_TYPE}");
      if ($RUN_TYPE eq "startup") {
        add_default($nl, 'init_abio_dic_dic14_init_file');
      } else {
        add_default($nl, 'init_abio_dic_dic14_init_file', 'val'=>"same_as_TS", 'noprepend'=>1);
      }
      add_default($nl, 'init_abio_dic_dic14_init_file_fmt');
    } else {
      add_default($nl, 'init_abio_dic_dic14_option', 'val'=>"ccsm_hybrid");
      add_default($nl, 'init_abio_dic_dic14_init_file', 'val'=>"$POP_PASSIVE_TRACER_RESTART_OVERRIDE", 'noprepend'=>1);
      add_default($nl, 'init_abio_dic_dic14_init_file_fmt', 'val'=>'nc');
    }
    add_default($nl, 'abio_dic_dic14_restfile_fallback', 'nofail'=>1);
    if (not $nl->get_value('abio_dic_dic14_restfile_fallback')) {
      add_default($nl, 'abio_dic_dic14_restfile_fallback', 'val'=>'unknown', 'noprepend'=>1);
    }
    add_default($nl, 'abio_tracer_init_ext(1)%mod_varname');
    add_default($nl, 'abio_tracer_init_ext(1)%file_varname');
    add_default($nl, 'abio_tracer_init_ext(1)%scale_factor');
    add_default($nl, 'abio_tracer_init_ext(2)%mod_varname');
    add_default($nl, 'abio_tracer_init_ext(2)%file_varname');
    add_default($nl, 'abio_tracer_init_ext(2)%scale_factor');
    add_default($nl, 'abio_surf_avg_dic_const');
    add_default($nl, 'abio_surf_avg_dic14_const');
    add_default($nl, 'abio_use_nml_surf_vals', 'runtype'=>"$RUN_TYPE");
    add_default($nl, 'abio_comp_surf_avg_freq_opt');
    add_default($nl, 'abio_comp_surf_avg_freq');
    add_default($nl, 'abio_atm_d14c_filename', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'abio_atm_co2_filename');
    add_default($nl, 'abio_atm_co2_opt', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'abio_atm_d14c_opt', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'abio_atm_co2_const', 'val'=>"$CCSM_CO2_PPMV");
    add_default($nl, 'abio_atm_d14c_const');
    add_default($nl, 'abio_atm_d14c_lat_band_vals');
    add_default($nl, 'abio_atm_model_year');
    add_default($nl, 'abio_atm_data_year');
 }

##########################################
# namelist group: ecosys_driver_nml      #
##########################################

my $ecosys_on = $cfg->get("use_ecosys");
# new hash to hold MARBL settings that affect POP ecosystem settings
my %ecosys_cfg;

if ($ecosys_on eq "TRUE") {
    # Add marbl_settings_file to POP namelist
    my $marbl_settings_file = "marbl_in";
    my $user_nl_pop   = "user_nl_pop";
    my $user_nl_marbl = "user_nl_marbl";
    if ($inst_string) {
      # append inst_string if multi-instance case
      $marbl_settings_file .= $inst_string;
      $user_nl_pop   .= $inst_string;
      $user_nl_marbl .= $inst_string;
    }

    # Abort if marbl_settings_file was set in user_nl_pop
    if ($nl->get_variable_value("ecosys_driver_nml", "marbl_settings_file") ne "") {
      print "ERROR: Do not set marbl_settings_file in ${user_nl_pop}.\n",
            "To change values in ${marbl_settings_file} you may override variables via ${user_nl_marbl},\n",
            "but POP relies on ${marbl_settings_file} for determining tracer counts and other\n",
            "configuration details that may not be consistent with an alternate file.\n";
      die;
    }
    add_default($nl, 'marbl_settings_file', 'val'=>"$marbl_settings_file");

    # Add MARBL vars to ecosys_cfg
    # Currently only hold onto ciso_on (suppress ciso variables if .false.)
    for my $varname ('ciso_on') {
        $ecosys_cfg{$varname} = `grep $varname $marbl_settings_file | cut -d '=' -f 2 | sed 's/^ //'`;
        chomp $ecosys_cfg{$varname};
    }

    add_default($nl, 'lmarginal_seas');
    add_default($nl, 'ecosys_tadvect_ctype');
    add_default($nl, 'ecosys_qsw_distrb_const');
}

############################################
# namelist group: ecosys_forcing_data_nml  #
############################################

if ($ecosys_on eq "TRUE") {
  add_default($nl, 'dust_flux_source');
  add_default($nl, 'dust_flux_input%filename');
  add_default($nl, 'dust_flux_input%file_fmt');
  add_default($nl, 'dust_flux_input%file_varname');
  add_default($nl, 'dust_flux_input%scale_factor');  # kg/m^2/sec -> g/cm^2/sec

  add_default($nl, 'iron_flux_source');
  add_default($nl, 'dust_ratio_thres', 'ocn_coupling'=>"$OCN_COUPLING");
  add_default($nl, 'fe_bioavail_frac_offset', 'ocn_coupling'=>"$OCN_COUPLING");
  add_default($nl, 'dust_ratio_to_fe_bioavail_frac_r', 'ocn_coupling'=>"$OCN_COUPLING");
  add_default($nl, 'iron_flux_input%filename');
  add_default($nl, 'iron_flux_input%file_fmt');
  add_default($nl, 'iron_flux_input%file_varname');
  add_default($nl, 'iron_flux_input%scale_factor');  # kg/m^2/sec -> nmol/cm^2/sec, 3.5% iron by weight

  add_default($nl, 'fesedflux_input%filename');
  add_default($nl, 'fesedflux_input%file_varname');
  add_default($nl, 'fesedflux_input%file_fmt');
  add_default($nl, 'fesedflux_input%scale_factor');  # umolFe/m2/day -> nmolFe/cm2/s

  add_default($nl, 'feventflux_input%filename');
  add_default($nl, 'feventflux_input%file_varname');
  add_default($nl, 'feventflux_input%file_fmt');
  add_default($nl, 'feventflux_input%scale_factor');  # umolFe/m2/day -> nmolFe/cm2/s

  add_default($nl, 'o2_consumption_scalef_opt', 'ocn_coupling'=>"$OCN_COUPLING");
  if ($nl->get_value('o2_consumption_scalef_opt') eq '\'file_time_invariant\'') {
    add_default($nl, 'o2_consumption_scalef_input%filename');
    add_default($nl, 'o2_consumption_scalef_input%file_varname');
    add_default($nl, 'o2_consumption_scalef_input%file_fmt');
    add_default($nl, 'o2_consumption_scalef_input%scale_factor');
  } else {
    add_default($nl, 'o2_consumption_scalef_const');
  }

  add_default($nl, 'p_remin_scalef_opt');
  if ($nl->get_value('p_remin_scalef_opt') eq '\'file_time_invariant\'') {
    add_default($nl, 'p_remin_scalef_input%filename');
    add_default($nl, 'p_remin_scalef_input%file_varname');
    add_default($nl, 'p_remin_scalef_input%file_fmt');
    add_default($nl, 'p_remin_scalef_input%scale_factor');
  } else {
    add_default($nl, 'p_remin_scalef_const');
  }

  if ($OCN_NDEP_DRIVER eq "TRUE"){
      add_default($nl, 'ndep_data_type', 'val'=>'driver');
  }else{
      add_default($nl, 'ndep_data_type', 'ocn_transient'=>"$OCN_TRANSIENT");
  }
  my $ndep_data_type = $nl->get_value('ndep_data_type');
  # Need to strip the quotes
  $ndep_data_type =~ s/['"]//g;
  if ($ndep_data_type eq "monthly-calendar") {
    add_default($nl, 'nox_flux_monthly_input%filename');
    add_default($nl, 'nox_flux_monthly_input%file_fmt');
    add_default($nl, 'nox_flux_monthly_input%file_varname');
    add_default($nl, 'nox_flux_monthly_input%scale_factor'); # kgN/m^2/sec -> nmolN/cm^2/sec
    add_default($nl, 'nhy_flux_monthly_input%filename');
    add_default($nl, 'nhy_flux_monthly_input%file_fmt');
    add_default($nl, 'nhy_flux_monthly_input%file_varname');
    add_default($nl, 'nhy_flux_monthly_input%scale_factor'); # kgN/m^2/sec -> nmolN/cm^2/sec
  } elsif ($ndep_data_type eq "shr_stream") {
    add_default($nl, 'ndep_shr_stream_year_first', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'ndep_shr_stream_year_last', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'ndep_shr_stream_year_align', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'ndep_shr_stream_file', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'ndep_shr_stream_scale_factor'); # kgN/m^2/sec -> nmolN/cm^2/sec
  } elsif ($ndep_data_type ne "driver") {
    print " ndep_data_type=$ndep_data_type not supported by ecosys module\n";
    die;
  }

  my $estuary_type = $nl->get_value('estuary_type');
  add_default($nl, 'riv_flux_shr_stream_file', 'estuary_type'=>$estuary_type, 'rof_grid'=>"$ROF_GRID");
  add_default($nl, 'riv_flux_shr_stream_year_first');
  add_default($nl, 'riv_flux_shr_stream_year_align', 'ocn_transient'=>"$OCN_TRANSIENT");
  add_default($nl, 'riv_flux_shr_stream_year_last', 'ocn_transient'=>"$OCN_TRANSIENT");
  add_default($nl, 'riv_flux_din_file_varname');
  add_default($nl, 'riv_flux_din_scale_factor');
  add_default($nl, 'riv_flux_dip_file_varname');
  add_default($nl, 'riv_flux_dip_scale_factor');
  add_default($nl, 'riv_flux_don_file_varname');
  add_default($nl, 'riv_flux_don_scale_factor');
  add_default($nl, 'riv_flux_dop_file_varname');
  add_default($nl, 'riv_flux_dop_scale_factor');
  add_default($nl, 'riv_flux_dsi_file_varname');
  add_default($nl, 'riv_flux_dsi_scale_factor');
  add_default($nl, 'riv_flux_dfe_file_varname');
  add_default($nl, 'riv_flux_dfe_scale_factor');
  add_default($nl, 'riv_flux_dic_file_varname');
  add_default($nl, 'riv_flux_dic_scale_factor');
  add_default($nl, 'riv_flux_alk_file_varname');
  add_default($nl, 'riv_flux_alk_scale_factor');
  add_default($nl, 'riv_flux_doc_file_varname');
  add_default($nl, 'riv_flux_doc_scale_factor');

  add_default($nl, 'gas_flux_forcing_opt');

  my $atm_co2_opt;
  if ($OCN_CO2_TYPE eq "constant") {
    $atm_co2_opt = "const";
  } elsif ($OCN_CO2_TYPE eq "prognostic") {
    $atm_co2_opt = "drv_prog";
  } elsif ($OCN_CO2_TYPE eq "diagnostic") {
    $atm_co2_opt = "drv_diag";
  } elsif ($OCN_CO2_TYPE eq "box_atm_co2") {
    $atm_co2_opt = "box_atm_co2";
  } else {
    print "error specifying atm_co2_opt \n";
    print "unknown OCN_CO2_TYPE:  $OCN_CO2_TYPE \n";
    die;
  }
  add_default($nl, 'atm_co2_opt', 'val'=>"$atm_co2_opt");
  add_default($nl, 'atm_co2_const', 'val'=>"$CCSM_CO2_PPMV");
  add_default($nl, 'box_atm_co2_init_val', 'val'=>"$CCSM_CO2_PPMV");
  add_default($nl, 'atm_alt_co2_opt', 'val'=>"const");
  add_default($nl, 'atm_alt_co2_const', 'val'=>"$CCSM_CO2_PPMV");

  # Only include carbon isotope variables if ciso_on = .true.
  if ($ecosys_cfg{'ciso_on'} eq '.true.') {
    add_default($nl, 'ciso_atm_d13c_opt', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'ciso_atm_d13c_const');
    add_default($nl, 'ciso_atm_d14c_opt', 'ocn_transient'=>"$OCN_TRANSIENT");
    add_default($nl, 'ciso_atm_d14c_const');

    my $ciso_atm_opt = $nl->get_value('ciso_atm_d13c_opt');
    if ($ciso_atm_opt eq '\'file\'') {
      add_default($nl, 'ciso_atm_d13c_filename', 'ocn_transient'=>"$OCN_TRANSIENT");
    }

    my $ciso_atm_opt = $nl->get_value('ciso_atm_d14c_opt');
    if ($ciso_atm_opt eq '\'lat_bands\'') {
      add_default($nl, 'ciso_atm_d14c_lat_band_vals');
    }
    if ($ciso_atm_opt eq '\'file\'') {
      add_default($nl, 'ciso_atm_d14c_filename', 'ocn_transient'=>"$OCN_TRANSIENT");
    }

    add_default($nl, 'ciso_atm_model_year');
    add_default($nl, 'ciso_atm_data_year');
  }

  add_default($nl, 'restorable_tracer_names');

  # The size of the array restore_data_filenames depends on the size of
  # restorable_tracer_names
  my @tracer_names = split(/,/,$nl->get_value('restorable_tracer_names'));
  my $tracer_cnt =$#tracer_names+1;
  add_default($nl, 'restore_data_filenames_derived');
  my $restore_data_file= "$tracer_cnt*" . $nl->get_value('restore_data_filenames_derived');
  add_default($nl, 'restore_data_filenames', 'val'=>"$restore_data_file", 'quote'=>'FALSE');
  add_default($nl, 'restore_data_file_varnames');

  add_default($nl, 'restore_inv_tau_opt');
  add_default($nl, 'restore_inv_tau_const');

  add_default($nl, 'restore_inv_tau_input%filename');
  add_default($nl, 'restore_inv_tau_input%file_varname');
  add_default($nl, 'restore_inv_tau_input%file_fmt');
  add_default($nl, 'restore_inv_tau_input%scale_factor');

  add_default($nl, 'surf_avg_dic_const');
  add_default($nl, 'surf_avg_alk_const');
  add_default($nl, 'surf_avg_di13c_const');
  add_default($nl, 'surf_avg_di14c_const');

  add_default($nl, 'iron_frac_in_atm_fine_dust');
  add_default($nl, 'iron_frac_in_atm_coarse_dust');
  add_default($nl, 'iron_frac_in_seaice_dust');
  add_default($nl, 'iron_frac_in_atm_bc');
  add_default($nl, 'iron_frac_in_seaice_bc');
}

##########################################
# namelist group: ecosys_tracer_init_nml #
##########################################

if ($ecosys_on eq "TRUE") {
  if ($POP_PASSIVE_TRACER_RESTART_OVERRIDE eq "none") {
    add_default($nl, 'init_ecosys_option', 'val'=>"ccsm_${RUN_TYPE}");
    if ($RUN_TYPE eq "startup") {
      add_default($nl, 'init_ecosys_init_file');
    } else {
      add_default($nl, 'init_ecosys_init_file', 'val'=>"same_as_TS", 'noprepend'=>1);
    }
    add_default($nl, 'init_ecosys_init_file_fmt');
  } else {
    add_default($nl, 'init_ecosys_option', 'val'=>"ccsm_hybrid");
    add_default($nl, 'init_ecosys_init_file', 'val'=>"$POP_PASSIVE_TRACER_RESTART_OVERRIDE", 'noprepend'=>1);
    add_default($nl, 'init_ecosys_init_file_fmt', 'val'=>'nc');
  }

# init_ecosys_init_file is set
  # (1) query init_ecosys_init_file
  # (2) add_default('ciso_init_ecosys_init_file', 'val' => '$init_ecosys_init_file')

  # By default, we use the same initial condition settings for the base
  # ecosystem module and the CISO module, but users have the option of
  # specifying different files if desired.
  my $init_ecosys_option = $nl->get_value("init_ecosys_option");
  my $init_ecosys_init_file = $nl->get_value("init_ecosys_init_file");
  my $init_ecosys_init_file_fmt = $nl->get_value("init_ecosys_init_file_fmt");

  # Only include carbon isotope variables if ciso_on = .true.
  if ($ecosys_cfg{'ciso_on'} eq '.true.') {
    add_default($nl, 'ciso_init_ecosys_option', 'val'=>"$init_ecosys_option");
    add_default($nl, 'ciso_init_ecosys_init_file', 'val'=>"$init_ecosys_init_file");
    add_default($nl, 'ciso_init_ecosys_init_file_fmt', 'val'=>"$init_ecosys_init_file_fmt");

   add_default($nl, 'ciso_tracer_init_ext(1)%mod_varname');
   add_default($nl, 'ciso_tracer_init_ext(1)%file_varname');
   add_default($nl, 'ciso_tracer_init_ext(1)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(2)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(2)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(2)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(3)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(3)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(3)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(4)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(4)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(4)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(5)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(5)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(5)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(6)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(6)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(6)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(7)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(7)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(7)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(8)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(8)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(8)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(9)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(9)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(9)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(10)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(10)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(10)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(11)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(11)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(11)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(12)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(12)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(12)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(13)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(13)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(13)%scale_factor');

    add_default($nl, 'ciso_tracer_init_ext(14)%mod_varname');
    add_default($nl, 'ciso_tracer_init_ext(14)%file_varname');
    add_default($nl, 'ciso_tracer_init_ext(14)%scale_factor');
  }

}

##########################################
# namelist group: ecosys derived vars    #
##########################################

if ($ecosys_on eq "TRUE") {
    add_default($nl, 'lecosys_tavg_all');

    # Set lecosys_tavg_alt_co2=.true. unless
    # atm_co2 and atm_alt_co2 forcing options are equivalent
    my $lecosys_tavg_alt_co2 = '.true.';

    my $atm_co2_opt     = $nl->get_value('atm_co2_opt');
    my $atm_alt_co2_opt = $nl->get_value('atm_alt_co2_opt');

    # strip quotes
    $atm_co2_opt     =~ s/[\'\"]//g;
    $atm_alt_co2_opt =~ s/[\'\"]//g;

    if ($atm_co2_opt eq $atm_alt_co2_opt) {
      # If both are set to 'const', then equivalence depends on the const value.
      if ($atm_co2_opt eq 'const') {
        my $atm_co2_const     = $nl->get_value('atm_co2_const');
        my $atm_alt_co2_const = $nl->get_value('atm_alt_co2_const');
        if ($atm_co2_const eq $atm_alt_co2_const) {
          $lecosys_tavg_alt_co2 = '.false.';
        }
      } else {
        $lecosys_tavg_alt_co2 = '.false.';
      }
    }
    add_default($nl, 'lecosys_tavg_alt_co2', 'val'=>"$lecosys_tavg_alt_co2");
}

##########################################
# namelist group: irf_nml                #
##########################################

my $IRF_on = $cfg->get("use_irf");
if ($IRF_on eq "TRUE") {
  add_default($nl, 'irf_tracer_file');
  add_default($nl, 'irf_tracer_file_ind_start');
}

######################################
# namelist group: mcog_nml           #
######################################

add_default($nl, 'lmcog');
add_default($nl, 'lmcog_debug');
add_default($nl, 'mcog_dagg_qsw_abort_thres');

my $lmcog = $nl->get_value('lmcog') eq '.true.';

my $mcog_ncols;
if ($lmcog) {
  $mcog_ncols = $ICE_NCAT+1;
} else {
  $mcog_ncols = 1;
}

# construct default mcog_col_to_bin array
my @mcog_col_to_bin = ();
for (my $ncol=1; $ncol<=$mcog_ncols; $ncol++) {
  push @mcog_col_to_bin, $ncol;
}

add_default($nl, 'mcog_col_to_bin', 'val'=>"@mcog_col_to_bin");

# verify that number of values in mcog_col_to_bin is correct
my $mcog_col_to_bin_string = $nl->get_variable_value("mcog_nml", "mcog_col_to_bin");
my @mcog_col_to_bin = split(/[, ]/, $mcog_col_to_bin_string);
if (@mcog_col_to_bin ne $mcog_ncols) {
  die "ERROR\nmcog_ncols = $mcog_ncols\nmcog_col_to_bin = @mcog_col_to_bin\nmcog_col_to_bin length doesn't match mcog_ncols\n";
}

# set CESM CPL_I2O_PER_CAT XML variable
my $cpl_i2o_per_cat="FALSE";
if ($lmcog) {
  $cpl_i2o_per_cat="TRUE";
}
my $cur_cpl_i2o_per_cat=`cd $CASEROOT ; ./xmlquery --value CPL_I2O_PER_CAT`;

if ($cur_cpl_i2o_per_cat ne $cpl_i2o_per_cat) {
  my $sysmod = "cd $CASEROOT ; ./xmlchange --noecho CPL_I2O_PER_CAT=$cpl_i2o_per_cat";
  system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
}

##########################################
# namelist group: tavg_nml               #
#        AND                             #
# tavg contents file                     #
##########################################

my $ltavg_streams_index_present;
my $ltavg_has_offset_date_values;
my $ltavg_one_time_header;
my $ltavg_nino_diags_requested;
my %tavg_nml = (tavg_freq_opt           => [],
    tavg_freq               => [],
    tavg_stream_filestrings => [],
    tavg_file_freq_opt      => [],
    tavg_file_freq          => [],
    tavg_start_opt          => [],
    tavg_start              => [],
    tavg_fmt_in             => [],
    tavg_fmt_out            => [],
    ltavg_has_offset_date   => [],
    tavg_offset_year        => [],
    tavg_offset_month       => [],
    tavg_offset_day         => [],
    ltavg_one_time_header   => [],
    );

if ($OCN_GRID =~ /^gx*/) {
    $ltavg_streams_index_present  = ".true.";
    $ltavg_nino_diags_requested   = ".true.";
} elsif ($OCN_GRID =~ /^tx*/) {
    $ltavg_streams_index_present  = ".true.";
    $ltavg_nino_diags_requested   = ".false.";
}

##########################################
# copy files to $RUNDIR                  #
##########################################

my $my_path = "${CASEROOT}/SourceMods/src.pop";

my @copy_files_to_input = ();
push @copy_files_to_input,"${OCN_GRID}_vert_grid";
push @copy_files_to_input,"${OCN_GRID}_region_ids";
push @copy_files_to_input,"${OCN_GRID}_history_contents";
push @copy_files_to_input,"${OCN_GRID}_movie_contents";
push @copy_files_to_input,"${OCN_GRID}_transport_contents";
push @copy_files_to_input,"${OCN_GRID}_depth_accel";
if ($OCN_GRID =~ /^gx*/) { push @copy_files_to_input,"${OCN_GRID}_overflow"; }

foreach my $file (@copy_files_to_input ) {
  if (-f "${my_path}/$file") {
    my $sysmod = "cp -fp ${my_path}/$file ${RUNDIR}/$file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  } else {
    my $sysmod = "cp -fp ${SRCROOT}/components/pop/input_templates/$file ${RUNDIR}/$file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  }
}

##########################################
# tavg contents file                     #
##########################################

# Create tavg contents file

my $pop_tavg_file  = "${CASEROOT}/Buildconf/popconf/${OCN_GRID}_tavg_contents";
my $sysmod;
my $file;

my $CASEBUILD = "$CASEROOT/Buildconf";

#-------------------------
# 1. base tavg contents
#-------------------------

# 1.a. create $CASEROOT/Buildconf/popconf/base.tavg.nml file
$sysmod;
$file = "ocn.base.tavg.csh";
my $env = "env CASEBUILD=$CASEBUILD OCN_GRID=$OCN_GRID ";
if (-f "${my_path}/$file"){
    $sysmod = "$env ${my_path}/${file}";
    system($sysmod) == 0 or die "ERROR ocn.base.tavg.csh: $sysmod failed: $?\n";
} else {
    $sysmod = "$env ${SRCROOT}/components/pop/input_templates/${file}";
    system($sysmod) == 0 or die "ERROR ocn.base.tavg.csh: $sysmod failed: $?\n";
}

# 1.b. read in popconf/base.tavg.nml file and fill in %tavg_nml entries
my $file = "${CASEROOT}/Buildconf/popconf/base.tavg.nml";
my $fh_in = new IO::File;
$fh_in->open("<$file") or die "** can't open file $file $\n";
my $line;
my $numcols;
while ($line = <$fh_in> )  {
    chomp($line);
    $line =~ /(.+)=(.+)/;
    my $key = $1;
    my $val = $2;
    $key =~ s/^\s+//;
    $key =~ s/\s+$//;
    $val =~ s/^\s+//;
    $val =~ s/\s+$//;
    my @val = split (' ',$val);
    push @{ $tavg_nml{$key} }, @val;
    my @cols = @{$tavg_nml{$key}};
    $numcols = $#cols + 1;
}
$fh_in->close();

# 1.d create base tavg contents file - in popconf/
#     either from $my_path (first) or from
my $base_tavg_file  = "${CASEROOT}/Buildconf/popconf/${OCN_GRID}_tavg_contents";
if ($OCN_TAVG_HIFREQ eq "TRUE") {
    # High-frequency tavg contents
    $file = "${OCN_GRID}_tavg_contents_high_freq";
} else {
    if ($OCN_ONEDIM eq "TRUE") {
      # 1D resolution dependent tavg contents
      $file = "${OCN_GRID}_1D_tavg_contents";
    } else {
      # Default resolution dependent tavg contents
      $file = "${OCN_GRID}_tavg_contents";
    }
}
if (-f "$my_path/$file") {
  $sysmod = "cp -fp ${my_path}/$file $base_tavg_file";
  system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
} else {
  if (-f "${SRCROOT}/components/pop/input_templates/$file") {
    $sysmod = "cp -fp ${SRCROOT}/components/pop/input_templates/$file $base_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  }
}


#-------------------------
# 2. budget tavg contents
#-------------------------
my $budget_tavg_file = "${CASEROOT}/Buildconf/popconf/budget_tavg_contents";
$file = "tavg_contents_tracer_budget_terms";
if ($OCN_TAVG_TRACER_BUDGET eq "TRUE") {
  # tracer budget tavg contents
  if (-f "${my_path}/$file") {
    $sysmod = "cp -fp ${my_path}/$file $budget_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  } else {
    $sysmod = "cp -fp ${SRCROOT}/components/pop/input_templates/$file $budget_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  }
  $sysmod = "cat $budget_tavg_file >> $pop_tavg_file";
  system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
}

#-------------------------
# 2b. gm_bolus tavg contents
#-------------------------
my $gm_bolus_tavg_file = "${CASEROOT}/Buildconf/popconf/gm_bolus_terms_tavg_contents";
if ($OCN_TAVG_HIFREQ eq "TRUE") {
  # High-frequency tavg contents
  $file = "gm_bolus_terms_tavg_contents_high_freq";
} else {
  $file = "gm_bolus_terms_tavg_contents";
}
if ($nl->get_value('diag_gm_bolus') eq '.true.') {
  # gm_bolus tavg contents
  if (-f "${my_path}/$file") {
    $sysmod = "cp -fp ${my_path}/$file $gm_bolus_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  } else {
    $sysmod = "cp -fp ${SRCROOT}/components/pop/input_templates/$file $gm_bolus_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  }
  $sysmod = "cat $gm_bolus_tavg_file >> $pop_tavg_file";
  system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
}

#-------------------------
# 2c. submeso tavg contents
#-------------------------
my $submeso_tavg_file = "${CASEROOT}/Buildconf/popconf/submeso_terms_tavg_contents";
if ($OCN_TAVG_HIFREQ eq "TRUE") {
  # High-frequency tavg contents
  $file = "submeso_terms_tavg_contents_high_freq";
} else {
  $file = "submeso_terms_tavg_contents";
}
if ($nl->get_value('lsubmesoscale_mixing') eq '.true.') {
  # submeso tavg contents
  if (-f "${my_path}/$file") {
    $sysmod = "cp -fp ${my_path}/$file $submeso_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  } else {
    $sysmod = "cp -fp ${SRCROOT}/components/pop/input_templates/$file $submeso_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  }
  $sysmod = "cat $submeso_tavg_file >> $pop_tavg_file";
  system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
}

#------------------------------------------
# 3. tracer and model physics tavg contents
#------------------------------------------
my @OCN_TAVG_MODULES = @OCN_TRACER_MODULES;
if ($lmcog) {
   push(@OCN_TAVG_MODULES, "mcog");
}

for my $module (@OCN_TAVG_MODULES) {

  my $file = "ocn.${module}.tavg.csh";
  my $my_stream = $numcols+1;
  my $env = "env CASEROOT=$CASEROOT CASEBUILD=$CASEBUILD OCN_GRID=$OCN_GRID OCN_TAVG_TRACER_BUDGET=$OCN_TAVG_TRACER_BUDGET POPROOT=$SRCROOT/components/pop";
  my @tavg_script_args = module_tavg_script_args($nl, $module, $cfg);
  if (-f "${my_path}/$file"){
      $sysmod = "$env ${my_path}/${file} $my_stream @tavg_script_args";
      system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  } else {
      $sysmod = "$env ${SRCROOT}/components/pop/input_templates/${file} $my_stream @tavg_script_args";
      system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
  }

  # Create new tracer stream namelists - if appropriate
  if (-f "${CASEBUILD}/popconf/${module}.tavg.nml") {
    my $fh_in = new IO::File;
    $fh_in->open("<${CASEBUILD}/popconf/$module.tavg.nml") or die "** can't open file ${CASEBUILD}/popconf/$module.tavg.nml \n";
    my $line;
    while ($line = <$fh_in> )  {
      chomp($line);
      $line =~ /(.+)=(.+)/;
      my $key = $1;
      my $val = $2;
      $key =~ s/^\s+//;
      $key =~ s/\s+$//;
      $val =~ s/^\s+//;
      $val =~ s/\s+$//;
      my @val = split (' ',$val);
      push @{ $tavg_nml{$key} }, @val;
      my @cols = @{$tavg_nml{$key}};
      $numcols = $#cols + 1;
###################### NOTE #######################################
#... should add a test to limit the total number of streams to nine
###################################################################
    }
    $fh_in->close();
  }
  $sysmod = "cat ${CASEBUILD}/popconf/${module}_tavg_contents >> $pop_tavg_file";
  system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
}

add_default($nl, 'n_tavg_streams',              'val'=>"$numcols");
add_default($nl, 'ltavg_streams_index_present', 'val'=>"$ltavg_streams_index_present");
add_default($nl, 'tavg_freq_opt',               'val'=>"@{$tavg_nml{'tavg_freq_opt'}}");
add_default($nl, 'tavg_freq',                   'val'=>"@{$tavg_nml{'tavg_freq'}}");
add_default($nl, 'tavg_file_freq_opt',          'val'=>"@{$tavg_nml{'tavg_file_freq_opt'}}");
add_default($nl, 'tavg_file_freq',              'val'=>"@{$tavg_nml{'tavg_file_freq'}}");
add_default($nl, 'tavg_stream_filestrings',     'val'=>"@{$tavg_nml{'tavg_stream_filestrings'}}");
add_default($nl, 'tavg_start_opt',              'val'=>"@{$tavg_nml{'tavg_start_opt'}}");
add_default($nl, 'tavg_start',                  'val'=>"@{$tavg_nml{'tavg_start'}}");
add_default($nl, 'tavg_fmt_in',                 'val'=>"@{$tavg_nml{'tavg_fmt_in'}}");
add_default($nl, 'tavg_fmt_out',                'val'=>"@{$tavg_nml{'tavg_fmt_out'}}");
add_default($nl, 'ltavg_has_offset_date',       'val'=>"@{$tavg_nml{'ltavg_has_offset_date'}}");
add_default($nl, 'tavg_offset_years',           'val'=>"@{$tavg_nml{'tavg_offset_years'}}");
add_default($nl, 'tavg_offset_months',          'val'=>"@{$tavg_nml{'tavg_offset_months'}}");
add_default($nl, 'tavg_offset_days',            'val'=>"@{$tavg_nml{'tavg_offset_days'}}");
add_default($nl, 'ltavg_one_time_header',       'val'=>"@{$tavg_nml{'ltavg_one_time_header'}}");
add_default($nl, 'ltavg_nino_diags_requested',  'val'=>"$ltavg_nino_diags_requested");
add_default($nl, 'tavg_contents',               'val'=>"${RUNDIR}/${OCN_GRID}_tavg_contents");
add_default($nl, 'tavg_infile',                 'val'=>"${output_h}restart.end");
add_default($nl, 'tavg_outfile',                'val'=>"$output_h");
add_default($nl, 'ltavg_ignore_extra_streams',  'val'=>".false.");

if (($ltidal_mixing =~ /true/) || ($lniw_mixing =~ /true/)) {
    push(@OCN_TAVG_MODULES, "vmix");
    my $module = 'vmix';
    my $file = "ocn.${module}.tavg.csh";
    my $my_stream = $numcols+1;
    my $env = "env CASEROOT=$CASEROOT CASEBUILD=$CASEBUILD OCN_GRID=$OCN_GRID OCN_TAVG_TRACER_BUDGET=$OCN_TAVG_TRACER_BUDGET";
    my @tavg_script_args = module_tavg_script_args($nl, 'vmix', $cfg);
    if (-f "${my_path}/$file"){
        $sysmod = "$env ${my_path}/${file} $my_stream @tavg_script_args";
        system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    } else {
        $sysmod = "$env ${SRCROOT}/components/pop/input_templates/${file} $my_stream @tavg_script_args";
        system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }

    # Create new tracer stream namelists - if appropriate
    if (-f "${CASEBUILD}/popconf/vmix.tavg.nml") {
      my $fh_in = new IO::File;
      $fh_in->open("<${CASEBUILD}/popconf/vmix.tavg.nml") or die "** can't open file ${CASEBUILD}/popconf/vmix.tavg.nml \n";
      my $line;
      while ($line = <$fh_in> )  {
        chomp($line);
        $line =~ /(.+)=(.+)/;
        my $key = $1;
        my $val = $2;
        $key =~ s/^\s+//;
        $key =~ s/\s+$//;
        $val =~ s/^\s+//;
        $val =~ s/\s+$//;
        my @val = split (' ',$val);
        push @{ $tavg_nml{$key} }, @val;
        my @cols = @{$tavg_nml{$key}};
        $numcols = $#cols + 1;
      }
      $fh_in->close();
    }
    $sysmod = "cat ${CASEBUILD}/popconf/vmix_tavg_contents >> $pop_tavg_file";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
}

#-----------------------------------------------------------------------------------------------
# *** Write output namelist file (pop_in) and input dataset list (pop.input_data_list) ***
#-----------------------------------------------------------------------------------------------
# Set namelist groups to be written out

my @groups = qw(domain_nml
                io_nml
                time_manager_nml
                grid_nml
                pop1d_nml
                init_ts_nml
                diagnostics_nml
                budget_diagnostics_nml
                bsf_diagnostic_nml
                restart_nml
                tavg_nml
                history_nml
                movie_nml
                solvers
                vertical_mix_nml
                vmix_const_nml
                vmix_rich_nml
                tidal_nml
                geoheatflux_nml
                vmix_kpp_nml
                advect_nml
                hmix_nml
                hmix_del2u_nml
                hmix_del2t_nml
                hmix_del4u_nml
                hmix_del4t_nml
                hmix_gm_nml
                hmix_gm_aniso_nml
                mix_submeso_nml
                hmix_aniso_nml
                state_nml
                baroclinic_nml
                ice_nml
                pressure_grad_nml
                topostress_nml
                damping_nml
                forcing_ws_nml
                forcing_shf_nml
                forcing_sfwf_nml
                forcing_pt_interior_nml
                forcing_s_interior_nml
                forcing_ap_nml
                coupled_nml
                sw_absorption_nml
                transports_nml
                context_nml
                overflows_nml
                niw_nml
                se_nml
                mcog_nml
                passive_tracers_on_nml
                estuary_nml);

if ($iage_on eq "TRUE") {
    push @groups, qw(iage_nml);
}
if ($cfc_on eq "TRUE" ) {
    push @groups, qw(cfc_nml);
}
if ($sf6_on eq "TRUE" ) {
    push @groups, qw(sf6_nml);
}
if ($ecosys_on eq "TRUE") {
    push @groups, qw(ecosys_driver_nml
                     ecosys_forcing_data_nml
                     ecosys_tracer_init_nml);
}
if ($abio_on eq "TRUE" ) {
    push @groups, qw(abio_dic_dic14_nml);
}
if ($IRF_on eq "TRUE" ) {
    push @groups, qw(irf_nml);
}

# Check for variables in the "derived" group, add them to appropriate group
for my $var ($nl->get_variable_names('derived')) {
  my @broken = split(/&/,$var);
  my $val = $nl->get_variable_value('derived', $var);
  $nl->set_variable_value($broken[1], $broken[0], $val);
}

# Consistency checks
if (pop_consistency_check($nl, $OCN_ONEDIM)) { exit 1; }

# Write out all groups  to pop_in
my $outfile = "./pop_in";
$nl->write($outfile, 'groups'=>\@groups);
if ($print>=2) { print "Writing pop ocean component namelist to $outfile $eol"; }

# Write  input dataset list.
check_input_files($nl, $DIN_LOC_ROOT, "../pop.input_data_list");

#-----------------------------------------------------------------------------------------------
# END OF MAIN SCRIPT
#===============================================================================================

#===============================================================================================
sub add_default {

# Add a value for the specified variable to the specified namelist object.  The variables
# already in the object have the higher precedence, so if the specified variable is already
# defined in the object then don't overwrite it, just return.
#
# This method checks the definition file and adds the variable to the correct
# namelist group.
#
# The value can be provided by using the optional argument key 'val' in the
# calling list.  Otherwise a default value is obtained from the namelist
# defaults object.  If no default value is found this method throws an exception
# unless the 'nofail' option is set true.
#
# Additional optional keyword=>value pairs may be specified.  If the keyword 'val' is
# not present, then any other keyword=>value pairs that are specified will be used to
# match attributes in the defaults file.
#
# Example 1: Specify the default value $val for the namelist variable $var in namelist
#            object $nl:
#
#  add_default($nl, $var, 'val'=>$val)
#
# Example 2: Add a default for variable $var if an appropriate value is found.  Otherwise
#            don't add the variable
#
#  add_default($nl, $var, 'nofail'=>1)
#
#
# ***** N.B. ***** This routine assumes the following variables are in package main::
#  $definition        -- the namelist definition object
#  $DIN_LOC_ROOT -- CCSM inputdata root directory

    my $nl = shift;     # namelist object
    my $var = shift;    # name of namelist variable
    my %opts = @_;      # options

    my $val = undef;

    # Query the definition to find which group the variable belongs to.  Exit if not found.
    my $group = $definition->get_group_name($var);
    unless ($group) {
      my $fname = $definition->get_file_name();
      die "$ProgName - ERROR: variable \"$var\" not found in namelist definition file $fname.\n";
    }

    # check whether the variable has a value in the namelist object -- if so then return
    $val = $nl->get_variable_value($group, $var);
    if (defined $val) { return; }

    # Look for a specified value in the options hash
    if (defined $opts{'val'}) {
      $val = $opts{'val'};
    }
    # or else get a value from namelist defaults object.
    # Note that if the 'val' key isn't in the hash, then just pass anything else
    # in %opts to the get_value method to be used as attributes that are matched
    # when looking for default values.
    else {
      $val = get_default_value($var, \%opts);
    }

    # if no value is found then exit w/ error (unless 'nofail' option set)
    unless (defined $val) {
      unless ($opts{'nofail'}) {
        print "$ProgName - ERROR: No default value found for $var\n".
              "user defined attributes:\n";
        foreach my $key (keys(%opts)) {
          if ($key ne 'nofail' and $key ne 'val') {
            print "key=$key  val=$opts{$key}\n";
          }
        }
        die;
      } else {
        return;
      }
    }

    # query the definition to find out if the variable is an input pathname
    my $is_input_pathname = $definition->is_input_pathname($var);

    # The default values for input pathnames are relative.  If the namelist
    # variable is defined to be an absolute pathname, then prepend
    # the CCSM inputdata root directory.
    # TODO: unless ignore_abs is passed as argument
    if ($is_input_pathname eq 'abs') {
      unless ($opts{'noprepend'}){
        $val = set_abs_filepath($val, $DIN_LOC_ROOT);
      }
    }

    # query the definition to find out if the variable takes a string value.
    # The returned string length will be >0 if $var is a string, and 0 if not.
    my $str_len = $definition->get_str_len($var);

    # If the variable is a string, then add quotes if they're missing
    if ($str_len > 0) {
      if ((not defined $opts{'quote'}) or ($opts{'quote'} eq 'TRUE')) {
        $val = quote_string($val);
      }
    }

    # set the value in the namelist
    $nl->set_variable_value($group, $var, $val);
}

#-----------------------------------------------------------------------------------------------

sub get_default_value {

# Return a default value for the requested variable.
# Return undef if no default found.
#
# ***** N.B. ***** This routine assumes the following variables are in package main::
#  $defaults          -- the namelist defaults object
#  $uc_defaults       -- the use CASE defaults object

    my $var_name    = lc(shift);   # name of namelist variable (CASE insensitive interface)
    my $usr_att_ref = shift;       # reference to hash containing user supplied attributes

    # Check in the namelist defaults
    return $defaults->get_value($var_name, $usr_att_ref);

}

#-----------------------------------------------------------------------------------------------

sub check_input_files {

# For each variable in the namelist which is an input dataset, check to see if it
# exists locally.
#
# ***** N.B. ***** This routine assumes the following variables are in package main::
#  $definition        -- the namelist definition object

    my $nl = shift;     # namelist object
    my $inputdata_rootdir = shift;    # if false prints test, else creates inputdata file
    my $outfile = shift;
    open(OUTFILE, ">>$outfile") if defined $inputdata_rootdir;

    # Look through all namelist groups
    my @groups = $nl->get_group_names();
    foreach my $group (@groups) {

  # Look through all variables in each group
  my @vars = $nl->get_variable_names($group);
  foreach my $var (@vars) {

    # Is the variable an input dataset?
    my $input_pathname_type = $definition->is_input_pathname($var);

    # If it is, check to see if variable contains non-file
    # For example, init_iage_init_file = "same_as_TS"
    my $is_a_file = 1;
    if ($input_pathname_type) {

      # Get pathname of input dataset
      my $pathname = $nl->get_variable_value($group, $var);
      # Need to strip the quotes
      $pathname =~ s/['"]//g;

      # bottom_cell_file could be 'unknown_bottom_cell'
      if (($var eq 'bottom_cell_file') and
          ($pathname eq 'unknown_bottom_cell')) {
        $is_a_file = 0;
      }

      # tidal_energy_file could be 'unknown_tidal_mixing'
      if (($var eq 'tidal_energy_file') and
          ($pathname eq 'unknown_tidal_mixing')) {
        $is_a_file = 0;
      }

      # niw_energy_file could be 'unknown_niw_energy'
      if (($var eq 'niw_energy_file') and
          ($pathname eq 'unknown_niw_energy')) {
        $is_a_file = 0;
      }

      # init_iage_file could be 'same_as_TS'
      if (($var eq 'init_iage_init_file') and
          ($pathname eq 'same_as_TS')) {
        $is_a_file = 0;
      }

      # init_ecosys_init_file could be 'same_as_TS'
      if (($var eq 'init_ecosys_init_file') and
          ($pathname eq 'same_as_TS')) {
        $is_a_file = 0;
      }

      # init_abio_dic_dic14_init_file could be 'same_as_TS'
      if (($var eq 'init_abio_dic_dic14_init_file') and
          ($pathname eq 'same_as_TS')) {
        $is_a_file = 0;
      }

      # abio_dic_dic14_restfile_fallback could be 'unknown'
      if (($var eq 'abio_dic_dic14_restfile_fallback') and
          ($pathname eq 'unknown')) {
        $is_a_file = 0;
      }


      # ciso_init_ecosys_init_file could be 'same_as_TS'
      if (($var eq 'ciso_init_ecosys_init_file') and
          ($pathname eq 'same_as_TS')) {
        $is_a_file = 0;
      }

    }

    # If it is, check whether it exists locally and print status
    if ($input_pathname_type and $is_a_file) {

      # Get pathname of input dataset
      my $pathname = $nl->get_variable_value($group, $var);
      # Need to strip the quotes
      $pathname =~ s/['"]//g;

      if ($input_pathname_type eq 'abs') {
        if ($inputdata_rootdir) {
          print OUTFILE "$var = $pathname\n";
          if ($pathname =~ /GC007v3.pop.r.0001-01-16-00000$/) {
            print OUTFILE "hdr_$var = $pathname.hdr\n";
          }
        } else {
          if (-e $pathname) {  # use -e rather than -f since the absolute pathname
            # might be a directory
            print "OK -- found $var = $pathname\n";
          } else {
            print "NOT FOUND:  $var = $pathname\n";
          }
        }
      } elsif ($input_pathname_type =~ m/rel:(.+)/o) {
        # The match provides the namelist variable that contains the
        # root directory for a relative filename
        my $rootdir_var = $1;
        my $rootdir = $nl->get_variable_value($group, $rootdir_var);
        $rootdir =~ s/['"]//g;
        if ($inputdata_rootdir) {
          $pathname = "$rootdir/$pathname";
          print OUTFILE "$var = $pathname\n";
        } else {
          if (-f "$rootdir/$pathname") {
            print "OK -- found $var = $rootdir/$pathname\n";
          } else {
            print "NOT FOUND:  $var = $rootdir/$pathname\n";
          }
        }
      }
    }
  }
}
    close OUTFILE if defined $inputdata_rootdir;
    return 0 if defined $inputdata_rootdir;
}

#-----------------------------------------------------------------------------------------------
sub set_abs_filepath {

# check whether the input filepath is an absolute path, and if it isn't then
# prepend a root directory

    my ($filepath, $rootdir) = @_;

    # strip any leading/trailing whitespace
    $filepath =~ s/^\s+//;
    $filepath =~ s/\s+$//;
    $rootdir  =~ s/^\s+//;
    $rootdir  =~ s/\s+$//;

    # strip any leading/trailing quotes
    $filepath =~ s/^['"]+//;
    $filepath =~ s/["']+$//;
    $rootdir =~ s/^['"]+//;
    $rootdir =~ s/["']+$//;

    my $out = $filepath;
    unless ( $filepath =~ /^\// ) {  # unless $filepath starts with a /
      $out = "$rootdir/$filepath"; # prepend the root directory
    }
    return $out;
}

#-------------------------------------------------------------------------------
sub valid_option {

    my ($val, @expect) = @_;
    my ($expect);

    $val =~ s/^\s+//;
    $val =~ s/\s+$//;
    foreach $expect (@expect) {
      if ($val =~ /^$expect$/i) { return $expect; }
    }
    return undef;
}

#-------------------------------------------------------------------------------
sub validate_options {

    my $source = shift;   # text string declaring the source of the options being validated
    my $opts   = shift;   # reference to hash that contains the options

    my ($opt, $old, @expect);

}

#-------------------------------------------------------------------------------
sub quote_string {
    my $str = shift;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    unless ($str =~ /^['"]/) {        #"'
        $str = "\'$str\'";
    }
    return $str;
}

#-------------------------------------------------------------------------------
sub expand_xml_variables_in_namelist {
    # Go through all variables in the namelist and expand any XML env settings in them
    my ($nl, $xmlvar_ref) = @_;

   foreach my $group ( $nl->get_group_names() ) {
       foreach my $var ( $nl->get_variable_names($group) ) {
          my $val    = $nl->get_variable_value($group, $var);
          my $newval = SetupTools::expand_xml_var( $val, $xmlvar_ref );
          if ( $newval ne $val ) {
             $nl->set_variable_value($group, $var, $newval);
          }
       }
   }
}

#-------------------------------------------------------------------------------
sub print_nl_to_screen {

  my $namelist = $_[0];
  # Loop through every group in the namelist
  for my $group ($namelist->get_group_names()) {
    # Loop through every variable in group
    for my $var ($namelist->get_variable_names($group)) {
      my $val = $namelist->get_variable_value($group, $var);
      # For derived type, $var contains variable name and group name
      if ($group eq "derived") {
        my @broken = split(/&/,$var);
        print "   * ", $broken[0], " = ", $val, " in \&", $broken[1], "\n";
      }
      else {
        print "   * ", $var, " = ", $val, " in \&", $group, "\n";
      }
    }
  }
}

#-------------------------------------------------------------------------------
sub valid_date {
# return 1 if given date ($$month/$$day/$$year) exists in calendar $cal
# otherwise subtract number of days in $$month from $$day, and increment
# $$month by 1 (also incrementing $$year if going from Dec to Jan) and
# then return 0.

  use feature "switch";

  my $day = shift;
  my $month = shift;
  my $year = shift;
  my $cal = shift;

  my $maxday = -1;
  given ($$month) {
    when (1) { $maxday = 31; }
    when (2) {
      if (($cal eq 'NO_LEAP') || (not leap($$year))) {
        $maxday = 28;
      } else {
        $maxday = 29;
      }
    }
    when (3) { $maxday = 31; }
    when (4) { $maxday = 30; }
    when (5) { $maxday = 31; }
    when (6) { $maxday = 30; }
    when (7) { $maxday = 31; }
    when (8) { $maxday = 31; }
    when (9) { $maxday = 30; }
    when (10) { $maxday = 31; }
    when (11) { $maxday = 30; }
    when (12) { $maxday = 31; }
  }
  if ($maxday == -1) {
    die "ERROR: can not figure out what month $$month is";
  }
  if ($$day > $maxday) {
    $$month++;
    if ($$month == 13) {
      $$year++;
      $$month = 1;
    }
    $$day = $$day - $maxday;
    return 0;
  }
  return 1;
}

#-------------------------------------------------------------------------------
sub leap() {
# return 1 if given year is a leap year, 0 otherwise

  my $year = shift;

  if (($year%4 == 0) && (($year%400 == 0) || ($year%100 != 0))) {
    return 1;
  }
  return 0;
}


#-------------------------------------------------------------------------------
sub pop_consistency_check() {

  my $nl = shift;
  my $OCN_ONEDIM = shift;
  my $l1Ddyn = $nl->get_value('l1Ddyn');
  my $lconst_Coriolis = $nl->get_value('lconst_Coriolis');
  my $lmin_Coriolis = $nl->get_value('lmin_Coriolis');

  # 1) l1Ddyn and $OCN_ONEDIM must match
  if (($l1Ddyn eq '.true.'  && $OCN_ONEDIM eq 'FALSE') or
      ($l1Ddyn eq '.false.' && $OCN_ONEDIM eq 'TRUE')) {
    print "POP namelist error: Do not set l1Ddyn in user_nl_pop, use ";
    print "OCN_ONEDIM in env_run.xml to make sure namelist is set properly.\n";
    return 1;
  }

  # 2) lconst_Coriolis = .true. => l1Ddyn = .true.
  if ($l1Ddyn eq '.false.' && $lconst_Coriolis eq '.true.') {
    print "POP namelist error: you can not run with ";
    print "lconst_Coriolis = .true. if l1Ddyn = .false.\n";
    return 1;
  }

  # 3) lmin_Coriolis = .true. => l1Ddyn = .true.
  if ($l1Ddyn eq '.false.' && $lmin_Coriolis eq '.true.') {
    print "POP namelist error: you can not run with ";
    print "lmin_Coriolis = .true. if l1Ddyn = .false.\n";
    return 1;
  }

  return 0;
}

#-------------------------------------------------------------------------------

sub module_tavg_script_args() {
  my $nl         = shift;
  my $module     = shift;
  my $cfg        = shift;
  if ($module eq "ecosys") {
    return ($nl->get_value('lecosys_tavg_all'),
            $nl->get_value('lecosys_tavg_alt_co2'));
  }
  if ($module eq "IRF") {
    my $IRF_NT   = $cfg->get("irf_nt");
    my $IRF_MODE = $cfg->get("irf_mode");
    return ($nl->get_variable_value("irf_nml", "irf_tracer_file"),
            $nl->get_variable_value("irf_nml", "irf_tracer_file_ind_start"),
            $IRF_NT,
            "'$IRF_MODE'");
  }
  if ($module eq "mcog") {
    use List::Util qw( max );
    my $mcog_col_to_bin_string = $nl->get_variable_value("mcog_nml", "mcog_col_to_bin");
    my @mcog_col_to_bin = split(/[, ]/, $mcog_col_to_bin_string);
    my $mcog_ncols = @mcog_col_to_bin;
    my $mcog_nbins = max @mcog_col_to_bin;
    return ($nl->get_variable_value("mcog_nml", "lmcog_debug"),
            $mcog_ncols,
            $mcog_nbins);
  }
  if ($module eq "vmix") {
    #-----------------------------------------------------------------------------------------------
    # Determine stream number of (first) 'once' stream; if no once stream, set stream number = -1
    #-----------------------------------------------------------------------------------------------
    my @tavg_freq_opt = split(',| ',$nl->get_value('tavg_freq_opt'));
    my $once_ind = -1;
    my $tmp_ind = 0;
    for my $single_freq_opt (@tavg_freq_opt) {
      $tmp_ind++;
      if (($once_ind == -1) && ($single_freq_opt eq "'once'")) {
        $once_ind = $tmp_ind;
      }
    }
    return ($once_ind,
            $nl->get_variable_value("tidal_nml", "ltidal_mixing"),
            $nl->get_variable_value("tidal_nml", "ltidal_lunar_cycle"),
            $nl->get_variable_value("tidal_nml", "tidal_mixing_method_choice"),
            $nl->get_variable_value("tidal_nml", "tidal_energy_choice"),
            $nl->get_variable_value("tidal_nml", "ltidal_melet_plot"),
            $nl->get_variable_value("niw_nml"  , "lniw_mixing"),
            $nl->get_variable_value("geoheatflux_nml", "geoheatflux_choice"),
            $nl->get_variable_value("vmix_kpp_nml", "lcvmix"));
  }
  return "";
}
